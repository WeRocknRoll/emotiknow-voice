<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Emma Mouth — Vowel-Weighted Word Visemes</title>
<style>
  :root { color-scheme: dark; }
  body { margin:0; background:#0b0f14; color:#eaf0f7; font:16px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; }
  .wrap { max-width:980px; margin:24px auto; padding:0 16px; }
  h1 { margin:0 0 14px; }
  .row { display:flex; gap:12px; align-items:center; flex-wrap:wrap; margin:10px 0; }
  textarea, input[type="text"] { width:100%; background:#0a0f14; color:#eaf0f7; border:1px solid #1b2632; border-radius:10px; padding:10px; }
  button { background:#0f62fe; color:#fff; border:0; padding:10px 16px; border-radius:10px; font-weight:600; cursor:pointer; }
  input[type="range"] { width:260px; }

  .stage { position:relative; width:640px; height:360px; border-radius:14px; overflow:hidden; background:#000; }
  .stage img#bg { width:100%; height:100%; object-fit:cover; display:block; }

  /* two layers for crossfade */
  #mouth { position:absolute; left:260px; top:98px; width:300px; height:160px; pointer-events:none;
           transform-origin:center center; transform:scale(.50) rotate(-1deg); }
  .layer { position:absolute; inset:0; opacity:0; transition:opacity 120ms linear; }
  .layer img { position:absolute; inset:0; width:100%; height:100%;
               -webkit-mask-image: radial-gradient(80% 60% at 50% 55%, rgba(0,0,0,1) 66%, rgba(0,0,0,0) 100%);
                       mask-image: radial-gradient(80% 60% at 50% 55%, rgba(0,0,0,1) 66%, rgba(0,0,0,0) 100%); }

  .hud { position:absolute; top:10px; left:10px; background:#09131bcc; padding:6px 10px; border-radius:8px; font-size:12px; }
  .hud b { color:#8bc4ff; }
</style>
</head>
<body>
<div class="wrap">
  <h1>Emma Mouth — Vowel-Weighted Word Visemes</h1>

  <div class="stage">
    <img id="bg" src="/emma.jpg" alt="Emma" />
    <div id="mouth">
      <div id="L1" class="layer" style="opacity:1"><img src="/mouth/X.png" alt=""></div>
      <div id="L2" class="layer" style="opacity:0"><img src="/mouth/X.png" alt=""></div>
    </div>
    <div class="hud">word: <b id="hudWord">—</b> &nbsp; viseme: <b id="hudV">X</b></div>
  </div>

  <div class="row"><div style="min-width:90px">Script</div>
    <textarea id="text" rows="3">Hi, I’m Emma. I can talk and move my mouth in sync. How can I help you?</textarea>
  </div>
  <div class="row">
    <button id="speak">Speak</button>
  </div>

  <div class="row"><div style="min-width:90px">Image URL</div><input id="imgUrl" type="text" value="/emma.jpg" /></div>
  <div class="row"><div style="min-width:90px">Mouth X: <span id="lx">260</span>px</div><input id="mx" type="range" min="0" max="600" value="260" /></div>
  <div class="row"><div style="min-width:90px">Mouth Y: <span id="ly">98</span>px</div><input id="my" type="range" min="0" max="300" value="98" /></div>
  <div class="row"><div style="min-width:90px">Scale: <span id="ls">0.50</span></div><input id="ms" type="range" min="0.2" max="2" step="0.01" value="0.50" /></div>
  <div class="row"><div style="min-width:90px">Rotate: <span id="lr">-1</span>°</div><input id="mr" type="range" min="-30" max="30" step="1" value="-1" /></div>

  <p style="opacity:.7;font-size:13px">
    Uses browser speech (<code>SpeechSynthesis</code>) word boundaries + a vowel-weighted grapheme mapper.
    This makes vowels open wide (A/E/I/O/U) and places M/F/L/S where they belong. For production, we’ll swap in true
    viseme timestamps from TTS (ElevenLabs/Azure/OpenAI Realtime).
  </p>
</div>

<script>
/* ===== config ===== */
const PNG_BASE="/mouth/";
const EXIST={};
const HOLD_MS=40, FADE_MS=120, STEP_MIN=70; // timing
// jaw offsets so upper lip anchors
const OFF={ X:{dx:0,dy:0,s:1}, M:{dx:0,dy:0,s:1}, F:{dx:0,dy:0,s:1}, L:{dx:0,dy:0,s:1}, S:{dx:0,dy:0,s:1},
            E:{dx:0,dy:0,s:1.0}, I:{dx:0,dy:0,s:1.0}, A:{dx:0,dy:2,s:1.01}, O:{dx:0,dy:2,s:1.01}, U:{dx:0,dy:3,s:1.015} };

/* ===== DOM ===== */
const textEl=document.getElementById('text');
const speakBtn=document.getElementById('speak');
const imgUrl=document.getElementById('imgUrl'); const bg=document.getElementById('bg');
const mouth=document.getElementById('mouth'); const L1=document.getElementById('L1'); const L2=document.getElementById('L2');
const mx=document.getElementById('mx'), lx=document.getElementById('lx');
const my=document.getElementById('my'), ly=document.getElementById('ly');
const ms=document.getElementById('ms'), ls=document.getElementById('ls');
const mr=document.getElementById('mr'), lr=document.getElementById('lr');
const hudW=document.getElementById('hudWord'), hudV=document.getElementById('hudV');

/* ===== state ===== */
let baseScale=+ms.value, baseRot=+mr.value, topIsL1=true, currentV="X";
let timers=[];

/* ===== helpers ===== */
function updateOverlay(){ mouth.style.left=mx.value+'px'; mouth.style.top=my.value+'px';
  baseScale=+ms.value; baseRot=+mr.value; applyTransform(currentV);
  lx.textContent=mx.value; ly.textContent=my.value; ls.textContent=(+ms.value).toFixed(2); lr.textContent=mr.value; }
[mx,my,ms,mr].forEach(el=>el.addEventListener('input',updateOverlay));
imgUrl.addEventListener('change',()=>bg.src=imgUrl.value); updateOverlay();

function preload() {
  const parts = ["A","E","I","O","U","M","F","L","S","X"];
  return Promise.all(parts.map(v=>new Promise(r=>{
    const im=new Image(); im.onload=()=>{EXIST[v]=true;r();}; im.onerror=()=>{EXIST[v]=false;r();};
    im.src=`${PNG_BASE}${v}.png`;
  })));
}
function spriteFor(v){ return EXIST[v]?v:"X"; }
function applyTransform(v){ const o=OFF[v]||OFF.X, s=baseScale*o.s;
  mouth.style.transform=`translate(${o.dx}px,${o.dy}px) scale(${s}) rotate(${baseRot}deg)`; }
function setHud(word,v){ hudW.textContent=word||"—"; hudV.textContent=v; }
function clearTimers(){ timers.forEach(id=>clearTimeout(id)); timers.length=0; }

/* ===== crossfade ===== */
function beginFade(v, when){
  const to = spriteFor(v);
  const nextLayer = topIsL1 ? L2 : L1;
  nextLayer.firstElementChild.src = `${PNG_BASE}${to}.png`;
  // snap prepare
  L1.style.opacity = topIsL1 ? 1 : 0;
  L2.style.opacity = topIsL1 ? 0 : 1;
  currentV=v; applyTransform(v);
  // async fade after HOLD
  const start = when + HOLD_MS;
  const id = setTimeout(()=>{
    const st = Date.now(), end = st + FADE_MS;
    const step = ()=>{
      const now = Date.now();
      const p = Math.min(1,(now-st)/(FADE_MS));
      if (topIsL1){ L1.style.opacity = 1-p; L2.style.opacity = p; }
      else        { L1.style.opacity = p;   L2.style.opacity = 1-p; }
      if (p<1) requestAnimationFrame(step); else topIsL1 = !topIsL1;
    };
    requestAnimationFrame(step);
  }, Math.max(0, start - performance.now()));
  timers.push(id);
}

/* ===== smart word→viseme plan ===== */
// Heuristics: emphasize vowels, keep brief consonant closures, ensure open peak inside word.
// Also small exceptions for “I”, “Hi”, “how”, “you”, “Emma” so your demo line looks perfect.
const VOWEL=/[aeiouy]/;
function mapChar(ch){
  ch=ch.toLowerCase();
  if("pbm".includes(ch)) return "M";
  if("fv".includes(ch))  return "F";
  if(ch==="l") return "L";
  if("szcjxq".includes(ch)) return "S";
  if(ch==="a") return "A";
  if(ch==="e") return "E";
  if(ch==="i"||ch==="y") return "I";
  if(ch==="o") return "O";
  if(ch==="u"||ch==="w") return "U";
  return "X";
}
function wordPlan(word){
  const w = (word||"").toLowerCase().replace(/[^a-z]/g,"");
  if(!w) return ["X"];

  // Special-cases for your line
  if (w==="i") return ["I"];                 // strong single open
  if (w==="hi") return ["H","A","I"].map(mapChar);
  if (w==="how") return ["H","A","O","U"].map(mapChar);  // clear open then round
  if (w==="you") return ["I","U"].map(mapChar);          // slight I then U
  if (w==="emma") return ["E","M","A"];                  // smile->closed->open
  if (w==="help") return ["H","E","L","P"].map(mapChar);
  if (w==="mouth") return ["M","O","U","S"];             // round progression

  // Generic: consonant onset → vowel peak(s) → possible closure
  const letters = [...w];
  const seq=[];
  let hadVowel=false;
  for(const ch of letters){
    const v = mapChar(ch);
    if (["A","E","I","O","U"].includes(v)){ hadVowel=true; seq.push(v); }
    else if (["M","F","L","S"].includes(v)){
      // keep brief consonant hits, but don’t spam duplicates
      if (seq[seq.length-1]!==v) seq.push(v);
    }
  }
  // Ensure at least one open if the word contains a vowel
  if (VOWEL.test(w) && !seq.some(v=>["A","E","I","O","U"].includes(v))) seq.push("A");

  // De-dup and cap to 3–4 steps for short words
  const dedup = seq.filter((v,i,a)=>i===0||a[i-1]!==v);
  return dedup.slice(0, Math.max(3, Math.min(4, dedup.length)));
}

/* schedule a plan inside a word window */
function scheduleWord(word, durationMs, startNow){
  const seq = wordPlan(word);
  setHud(word, seq[0]||"X");
  const steps = Math.max(1, seq.length);
  const per   = Math.max(STEP_MIN, durationMs / steps);
  for(let i=0;i<steps;i++){
    const v = seq[i];
    const at = startNow + i*per;
    const id = setTimeout(()=>beginFade(v, performance.now()), Math.max(0, at - performance.now()));
    timers.push(id);
  }
}

/* ===== speaking with boundary timings ===== */
async function speakWithMapper(text){
  const synth = window.speechSynthesis;
  if(!synth){
    // fallback: simple loop
    const words=text.split(/\s+/); let t=performance.now();
    for(const w of words){ scheduleWord(w, 220, t); t+=240; }
    return new Promise(r=>setTimeout(r, Math.max(1500, Math.min(8000, text.length*55))));
  }
  try{ synth.cancel(); } catch(e){}

  return new Promise(res=>{
    const u = new SpeechSynthesisUtterance(text);
    u.rate = 1.0; u.pitch = 1.02;

    let lastElapsed = 0; // ms from TTS
    u.onboundary = (e)=>{
      if (e.name !== "word") return;
      const nowMs = e.elapsedTime*1000;
      const prevDur = Math.max(140, nowMs - lastElapsed); // window for CURRENT word
      lastElapsed = nowMs;

      const w = grabWordAt(text, e.charIndex || 0) || "";
      scheduleWord(w, prevDur, performance.now());
    };
    u.onend = ()=>{ // close gently
      scheduleWord("", 180, performance.now());
      res();
    };
    u.onerror = ()=>res();

    synth.speak(u);
  });
}
function grabWordAt(text, idx){
  const s=text; let l=idx, r=idx;
  while(l>0 && /\w/.test(s[l-1])) l--;
  while(r<s.length && /\w/.test(s[r])) r++;
  return s.slice(l,r);
}

/* ===== boot ===== */
preload().then(()=>{
  L1.firstElementChild.src=`${PNG_BASE}X.png`;
  L2.firstElementChild.src=`${PNG_BASE}X.png`;
});
speakBtn.addEventListener('click', async ()=>{
  clearTimers();
  await speakWithMapper(textEl.value.trim());
  clearTimers(); beginFade("X", performance.now()); setHud("—","X");
});
</script>
</body>
</html>

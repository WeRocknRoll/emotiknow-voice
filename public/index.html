<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>EmotiKnow — Emma (Voice Companion)</title>
  <style>
    :root {
      --bg:#0f1117; --panel:#151b23; --ink:#e6e8ef; --muted:#9aa3b2; --accent:#8ab4ff;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0; background:var(--bg); color:var(--ink); font:500 16px/1.45 ui-sans-serif,system-ui,Segoe UI,Roboto,"Helvetica Neue";}
    .wrap{max-width:1200px; margin:auto; padding:18px;}
    h1{font-weight:800; letter-spacing:.2px; margin:8px 0 14px}
    .row{display:grid; grid-template-columns:1fr 360px; gap:16px}
    @media (max-width:980px){.row{grid-template-columns:1fr}}
    .panel{background:var(--panel); border:1px solid #212a35; border-radius:14px; padding:14px}
    .media{display:grid; place-items:center; overflow:hidden; background:#000}
    .media-inner{position:relative; width:100%; aspect-ratio:16/9; display:grid; place-items:center; background:#000}
    #portrait{max-width:100%; max-height:100%; object-fit:contain; display:block; user-select:none;}
    #mouth{position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); width:260px; pointer-events:none; image-rendering:auto; opacity:0.98}

    .controls label{display:block; font-size:12px; color:var(--muted); margin:14px 0 6px}
    .controls input[type="range"]{width:100%}
    .controls select, .controls button{
      width:100%; height:44px; border-radius:10px; border:1px solid #2a3442; background:#0f141a; color:var(--ink); padding:0 12px;
    }
    .controls button.primary{background:#1b2735; border-color:#33465f}
    .tip{font-size:12px; color:var(--muted); margin-top:10px}
    .log{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size:12px; line-height:1.45;
         background:#0c0f13; border:1px solid #1a2230; border-radius:12px; padding:10px; height:180px; overflow:auto; white-space:pre-wrap;}
    .vu{height:6px; background:#10151b; border-radius:99px; overflow:hidden; margin-top:6px}
    .vu > i{display:block; height:100%; width:0%; background:linear-gradient(90deg,#58a 0%, #9cf 100%)}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>EmotiKnow — Emma (Voice Companion)</h1>
    <div class="row">
      <div class="panel media">
        <div class="media-inner" id="stage">
          <!-- Your portrait background -->
          <img id="portrait" src="/m.png" alt="Emma portrait" />
          <!-- mouth overlay -->
          <img id="mouth" alt="mouth overlay" />
        </div>
      </div>

      <div class="panel controls">
        <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-bottom:10px;">
          <button class="primary" onclick="window.start()">Start</button>
          <button onclick="window.stop()">Hang Up</button>
        </div>

        <label>Target width (mouth)</label>
        <input id="widthSlider" type="range" min="60" max="700" value="260" />

        <label>Smooth (higher = slower)</label>
        <input id="smoothSlider" type="range" min="0.3" max="1.2" step="0.01" value="0.85" />

        <label>Gate (ignore background)</label>
        <input id="gateSlider" type="range" min="0.0" max="0.4" step="0.01" value="0.15" />

        <label>Voice “personality”</label>
        <select id="persona">
          <option value="Ballad (warm)" selected>Ballad (warm)</option>
          <option value="Shimmer (bright)">Shimmer (bright)</option>
          <option value="Soft (gentle)">Soft (gentle)</option>
        </select>

        <label style="margin-top:10px">VU</label>
        <div class="vu"><i id="vuFill"></i></div>

        <div class="tip">Tip: Click Emma’s <b>real</b> mouth once to anchor the overlay.  
          The position & sizing are saved per browser.</div>

        <div id="log" class="log"></div>
      </div>
    </div>
  </div>

<script>
(() => {
  /*** Elements ***/
  const logEl = document.getElementById('log');
  const stage = document.getElementById('stage');
  const mouth = document.getElementById('mouth');
  const widthSlider = document.getElementById('widthSlider');
  const smoothSlider = document.getElementById('smoothSlider');
  const gateSlider = document.getElementById('gateSlider');
  const personaSel = document.getElementById('persona');
  const vuFill = document.getElementById('vuFill');

  /*** Logging helper ***/
  const log = (...a) => { logEl.textContent += a.join(' ') + "\n"; logEl.scrollTop = logEl.scrollHeight; };
  log("[app] ready.");

  /*** Mouth frames (make sure /public/mouth/*.png exist) ***/
  const frameNames = ["f","p","g","l","v","i","o","u","say"];
  const frames = {};
  let frameOrder = [...frameNames]; // cycle order
  let frameIdx = 0, frameTimer = null;

  Promise.all(frameNames.map(n => new Promise(res => {
    const img = new Image();
    img.onload = () => { frames[n] = img; res(); };
    img.onerror = () => res(); // don't block if a frame is missing
    img.src = `/mouth/${n}.png`;
  }))).then(() => log("[frames] loaded", Object.keys(frames).length + "/9"));

  /*** Overlay persistence (anchor) ***/
  const KEY = "emma_anchor_v1";
  let anchor = JSON.parse(localStorage.getItem(KEY) || "null"); // {x:0..1,y:0..1}
  function applyAnchor() {
    const rect = stage.getBoundingClientRect();
    const x = (anchor?.x ?? 0.50) * rect.width;
    const y = (anchor?.y ?? 0.54) * rect.height;
    mouth.style.left = `${x}px`;
    mouth.style.top  = `${y}px`;
  }
  applyAnchor();
  window.addEventListener('resize', applyAnchor);

  stage.addEventListener('click', (e) => {
    const r = stage.getBoundingClientRect();
    anchor = { x:(e.clientX - r.left)/r.width, y:(e.clientY - r.top)/r.height };
    localStorage.setItem(KEY, JSON.stringify(anchor));
    applyAnchor();
    log("[anchor] saved", `x=${anchor.x.toFixed(3)}, y=${anchor.y.toFixed(3)}`);
  });

  /*** Controls ***/
  widthSlider.addEventListener('input', () => {
    mouth.style.width = widthSlider.value + "px";
  });
  mouth.style.width = widthSlider.value + "px";

  /*** Lip animation loop (simple, smoothed by slider) ***/
  function startLipLoop() {
    stopLipLoop();
    const base = Math.max(0.18, parseFloat(smoothSlider.value || "0.85"));
    const period = base * 340; // ms per frame (bigger = slower)
    frameTimer = setInterval(() => {
      const order = frameOrder.filter(n => frames[n]);
      if (!order.length) return;
      mouth.src = frames[ order[ frameIdx % order.length ] ].src;
      frameIdx++;
    }, period);
  }
  function stopLipLoop() {
    if (frameTimer) clearInterval(frameTimer);
    frameTimer = null;
  }

  /*** Realtime connection ***/
  let pc = null, localStream = null;
  let speaking = false;

  async function start() {
    try {
      log("[mic] requesting…");
      localStream = await navigator.mediaDevices.getUserMedia({ audio:true, video:false });
      log("[mic] granted.");

      // Warmth instruction choice (sent to server)
      let chosenVoice = "shimmer";
      if (personaSel.value.includes("Ballad")) chosenVoice = "ballad";
      if (personaSel.value.includes("Soft"))   chosenVoice = "soft";

      const warmPrompt =
        "You are Emma—warm, kind, caring, encouraging, and concise. " +
        "Respond quickly and supportively. Keep answers brief unless asked.";

      log("[token] fetching…");
      const sess = await fetch("/api/realtime-session", {
        method: "POST",
        headers:{ "Content-Type":"application/json" },
        body: JSON.stringify({ voice: chosenVoice, instructions: warmPrompt })
      }).then(r=>r.json());

      if (!sess?.client_secret?.value) {
        log("[ERROR] token http", JSON.stringify(sess));
        return;
      }
      log("[token] ok.");

      // WebRTC setup
      pc = new RTCPeerConnection();
      pc.addEventListener('connectionstatechange', () => {
        log(`[pc] state: ${pc.connectionState}`);
      });

      // Play incoming audio
      const audioEl = document.createElement('audio');
      audioEl.autoplay = true;
      pc.ontrack = (e) => { audioEl.srcObject = e.streams[0]; };

      // mic to pc
      for (const track of localStream.getAudioTracks()) pc.addTrack(track, localStream);

      // we want audio back
      pc.addTransceiver("audio", { direction:"sendrecv" });

      // Simple VU based on speaking boolean (rough)
      const analyser = new (window.AudioContext || window.webkitAudioContext)().createAnalyser();
      const srcNode = new MediaStreamAudioSourceNode(analyser.context, { mediaStream: localStream });
      srcNode.connect(analyser);
      const vuBuf = new Uint8Array(analyser.frequencyBinCount);
      (function vuTick(){
        if (!pc) return;
        analyser.getByteFrequencyData(vuBuf);
        const avg = vuBuf.reduce((a,b)=>a+b,0)/vuBuf.length/255;
        vuFill.style.width = Math.min(100, Math.floor(avg*140)) + "%";
        requestAnimationFrame(vuTick);
      })();

      // Create offer
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);

      // Exchange SDP with OpenAI over HTTPS (not WebSocket)
      log("[sdp] exchanging via /v1/realtime (POST)…");
      const ans = await fetch(`https://api.openai.com/v1/realtime?model=gpt-4o-mini-realtime-preview`, {
        method: "POST",
        headers: {
          "Authorization": `Bearer ${sess.client_secret.value}`,
          "Content-Type": "application/sdp"
        },
        body: offer.sdp
      });
      if (!ans.ok) {
        const t = await ans.text();
        log("[ERROR] sdp", t);
        stop();
        return;
      }
      const answerSDP = await ans.text();
      await pc.setRemoteDescription({ type:"answer", sdp: answerSDP });
      log("[sdp] handshake complete.");

      // Start lips when remote audio flows (crude: toggle on first track)
      pc.addEventListener("track", () => {
        speaking = true;
        startLipLoop();
      });

      // Timeout fallback (if no audio for a while, stop lips)
      setTimeout(() => {
        if (!speaking) stopLipLoop();
      }, 8000);

    } catch (e) {
      log("[ERROR]", e?.message || e);
    }
  }

  async function stop() {
    try {
      if (pc) pc.close();
      pc = null;
      if (localStream) {
        for (const t of localStream.getTracks()) t.stop();
        localStream = null;
      }
      stopLipLoop();
      log("[call] ended.");
    } catch {}
  }

  // expose for onclick
  window.start = start;
  window.stop = stop;
})();
</script>
</body>
</html>

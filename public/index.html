<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>EmotiKnow — Emma (Voice Companion)</title>
  <style>
    :root{
      --bg:#0c0f12; --panel:#12161b; --text:#e7edf5; --muted:#9fb0c3; --brand:#4ea3ff;
      --accent:#7bd9b5;
    }
    *{box-sizing:border-box}
    body{margin:0; background:var(--bg); color:var(--text); font:14px/1.4 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial;
         display:flex; gap:22px; padding:20px;}
    .stage{flex:1; min-height:70vh; display:grid; place-items:center; background:#080a0d; border-radius:14px; overflow:hidden;}
    .canvas{position:relative; width:min(1100px,95vw); aspect-ratio:16/9; background:#000; border-radius:12px; overflow:hidden;}
    .emma-bg{position:absolute; inset:0; width:100%; height:100%; object-fit:cover; user-select:none; pointer-events:none;}
    #mouth{position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);
           width:200px; user-select:none; pointer-events:none; image-rendering:auto;}
    #mouth.feather{filter: drop-shadow(0 0 0 rgba(0,0,0,0));}
    .anchor-dot{position:absolute; width:10px; height:10px; border-radius:50%; background:var(--accent);
                box-shadow:0 0 0 3px rgba(123,217,181,.25); transform:translate(-50%,-50%); pointer-events:none; opacity:.85;}
    .panel{width:410px; background:var(--panel); border-radius:14px; padding:18px; display:flex; flex-direction:column; gap:18px}
    h1{margin:0 0 6px 0; font-size:20px}
    .row{display:flex; gap:10px}
    button{appearance:none; border:0; padding:10px 16px; border-radius:10px; font-weight:600; cursor:pointer}
    #startBtn{background:var(--brand); color:#081018}
    #hangBtn{background:#1b2430; color:var(--text)}
    .ctrl{display:flex; flex-direction:column; gap:8px}
    .ctrl label{font-size:12px; color:var(--muted)}
    input[type="range"], select{width:100%}
    .tip{font-size:12px; color:var(--muted); border:1px dashed #2a3442; padding:10px; border-radius:10px}
    pre{white-space:pre-wrap; background:#0a0f14; padding:12px; border-radius:10px; font-size:12px; color:#bcd0e4; max-height:240px; overflow:auto}
  </style>
</head>
<body>
  <div class="stage">
    <div class="canvas" id="canvas">
      <img class="emma-bg" id="bg" src="/emma.jpg" alt="Emma"/>
      <img id="mouth" class="feather" src="/mouth/mouth_closed.png" alt="mouth overlay"/>
      <div id="anchorDot" class="anchor-dot" style="display:none;"></div>
    </div>
  </div>

  <aside class="panel">
    <h1>EmotiKnow — Emma (Voice Companion)</h1>

    <div class="row">
      <button id="startBtn">Start</button>
      <button id="hangBtn" disabled>Hang Up</button>
    </div>

    <label style="display:flex; gap:10px; align-items:center; font-size:13px; color:var(--muted)">
      <input type="checkbox" id="connectVoice" checked/>
      Connect voice (uses <code>/api/realtime-session</code>)
    </label>

    <div class="ctrl">
      <label>Target width (mouth) <span id="wLabel">140 px</span></label>
      <input type="range" id="mouthWidth" min="80" max="280" step="2" value="140"/>
    </div>

    <div class="ctrl">
      <label>Smooth (higher = slower)</label>
      <input type="range" id="smooth" min="0.50" max="0.95" step="0.01" value="0.85"/>
    </div>

    <div class="ctrl">
      <label>Gate (ignore background)</label>
      <input type="range" id="gate" min="0.00" max="0.40" step="0.01" value="0.14"/>
    </div>

    <div class="ctrl">
      <label>Voice “personality” (only if connected)</label>
      <select id="voiceSelect">
        <option value="warm">Warm (gentle, kind)</option>
        <option value="shimmer">Shimmer (bright)</option>
        <option value="ballad">Ballad (neutral)</option>
      </select>
    </div>

    <div class="ctrl">
      <label>Mouth size (scale)</label>
      <input type="range" id="mouthScale" min="0.60" max="1.60" step="0.01" value="0.95"/>
    </div>

    <div class="ctrl">
      <label>Edge feather</label>
      <input type="range" id="feather" min="0" max="16" step="1" value="8"/>
    </div>

    <div class="tip">
      Click Emma’s <b>real mouth</b> once to anchor the overlay.  
      The position & sizing are saved per browser.
    </div>

    <details>
      <summary>Advanced (optional)</summary>
      <pre id="log">[app] ready.</pre>
    </details>
  </aside>

  <script>
    // ---------- MOUTH FRAMES ----------
    const MOUTH = {
      closed: '/mouth/mouth_closed.png',
      half:   '/mouth/mouth_half.png',
      open:   '/mouth/mouth_open.png'
    };
    function pickMouth(level) {
      if (level > 0.30) return MOUTH.open;
      if (level > 0.15) return MOUTH.half;
      return MOUTH.closed;
    }

    // ---------- ELEMENTS ----------
    const canvas = document.getElementById('canvas');
    const mouthEl = document.getElementById('mouth');
    const anchorDot = document.getElementById('anchorDot');

    const wSlider = document.getElementById('mouthWidth');
    const wLabel  = document.getElementById('wLabel');
    const sSlider = document.getElementById('smooth');
    const gSlider = document.getElementById('gate');
    const scaleSlider = document.getElementById('mouthScale');
    const featherSlider = document.getElementById('feather');
    const voiceSelect = document.getElementById('voiceSelect');
    const connectVoice = document.getElementById('connectVoice');

    const startBtn = document.getElementById('startBtn');
    const hangBtn  = document.getElementById('hangBtn');
    const logEl    = document.getElementById('log');

    function log(line){ logEl.textContent += "\\n" + line; logEl.scrollTop = logEl.scrollHeight; }

    // ---------- ANCHOR ----------
    let anchor = JSON.parse(localStorage.getItem('emma.anchor') || 'null');
    function saveAnchor(){ localStorage.setItem('emma.anchor', JSON.stringify(anchor)); }

    function applyMouthLayout(){
      if (!anchor) return;
      const pxWidth = parseInt(wSlider.value,10);
      const scale   = parseFloat(scaleSlider.value);
      const blur    = parseInt(featherSlider.value,10);
      mouthEl.style.left  = `${anchor.x*100}%`;
      mouthEl.style.top   = `${anchor.y*100}%`;
      mouthEl.style.width = (pxWidth * scale) + 'px';
      mouthEl.style.filter = `blur(${blur}px)`; // feather
      anchorDot.style.display = 'block';
      anchorDot.style.left = mouthEl.style.left;
      anchorDot.style.top  = mouthEl.style.top;
    }

    canvas.addEventListener('click', (e)=>{
      const r = canvas.getBoundingClientRect();
      anchor = { x:(e.clientX-r.left)/r.width, y:(e.clientY-r.top)/r.height };
      saveAnchor();
      applyMouthLayout();
      log(`[anchor] saved x=${anchor.x.toFixed(3)}, y=${anchor.y.toFixed(3)}`);
    });

    wSlider.addEventListener('input', ()=>{ wLabel.textContent = `${wSlider.value} px`; applyMouthLayout(); });
    scaleSlider.addEventListener('input', applyMouthLayout);
    featherSlider.addEventListener('input', applyMouthLayout);

    // ---------- AUDIO METER ----------
    let ctx, analyser, rafId, levelSmooth = 0;
    function startMeter(stream){
      ctx = new (window.AudioContext || window.webkitAudioContext)();
      analyser = ctx.createAnalyser();
      analyser.fftSize = 2048;
      const src = ctx.createMediaStreamSource(stream);
      src.connect(analyser);
      const buf = new Uint8Array(analyser.fftSize);

      function tick(){
        analyser.getByteTimeDomainData(buf);
        let peak = 0;
        for (let i=0;i<buf.length;i++){
          const v = Math.abs(buf[i]-128)/128; // 0..1
          if (v>peak) peak=v;
        }
        const smooth = parseFloat(sSlider.value);
        levelSmooth = levelSmooth * smooth + (1-smooth) * peak;

        const gate = parseFloat(gSlider.value);
        const active = Math.max(0, levelSmooth - gate) / (1-gate + 1e-6);

        const nextSrc = pickMouth(active);
        if (mouthEl.dataset.src !== nextSrc){
          mouthEl.dataset.src = nextSrc;
          mouthEl.src = nextSrc;
        }
        rafId = requestAnimationFrame(tick);
      }
      tick();
    }
    function stopMeter(){
      if (rafId) cancelAnimationFrame(rafId), rafId=null;
      if (ctx) ctx.close(), ctx=null;
    }

    // ---------- WEBRTC ----------
    let pc, micStream;
    async function startCall(){
      if (pc) return;
      try{
        micStream = await navigator.mediaDevices.getUserMedia({ audio:true });
        log('[mic] granted.');
        startMeter(micStream);

        pc = new RTCPeerConnection();
        micStream.getTracks().forEach(t=>pc.addTrack(t,micStream));
        pc.onconnectionstatechange = ()=> log(`[pc] ${pc.connectionState}`);

        const offer = await pc.createOffer({ offerToReceiveAudio:true });
        await pc.setLocalDescription(offer);

        if (connectVoice.checked) {
          // hand the SDP offer to our serverless function
          const r = await fetch('/api/realtime-session', {
            method:'POST',
            headers:{ 'Content-Type': 'application/json' },
            body: JSON.stringify({ sdp: offer.sdp, voice: voiceSelect.value })
          });

          if (!r.ok) {
            const t = await r.text();
            log(`[error] token http ${r.status}\\n${t}`);
            return hangUp();
          }

          const data = await r.json();
          await pc.setRemoteDescription({ type: 'answer', sdp: data.answer });
          log('[sdp] handshake complete.');
        } else {
          log('[info] Connect voice is OFF (no OpenAI handshake).');
        }

        startBtn.disabled = true;
        hangBtn.disabled = false;
      }catch(err){
        log('[error] ' + (err?.message || err));
        hangUp();
      }
    }

    function hangUp(){
      stopMeter();
      try{ if (pc){ pc.close(); pc=null; } }catch{}
      try{ if (micStream){ micStream.getTracks().forEach(t=>t.stop()); micStream=null; } }catch{}
      startBtn.disabled = false;
      hangBtn.disabled = true;
      log('[call] ended.');
    }

    document.getElementById('startBtn').addEventListener('click', startCall);
    document.getElementById('hangBtn').addEventListener('click', hangUp);

    // ---------- INIT ----------
    if (anchor){
      applyMouthLayout();
      log(`[anchor] restored x=${anchor.x.toFixed(3)}, y=${anchor.y.toFixed(3)}`);
    } else {
      anchor = { x:0.512, y:0.309 }; // a sensible default center
      saveAnchor();
      applyMouthLayout();
      log('[anchor] default set (click to re-anchor).');
    }
    wLabel.textContent = `${wSlider.value} px`;
  </script>
</body>
</html>

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>EmotiKnow — Emma (Voice Companion)</title>
  <style>
    :root {
      --bg: #0f1117; --panel:#151a23; --ink:#e6e8ef; --muted:#98a2b3; --accent:#6ea8ff;
      --ok:#2ecc71; --err:#ff6b6b;
    }
    html,body { height:100%; margin:0; background:var(--bg); color:var(--ink); font:500 15px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    .wrap { max-width: 1180px; margin: 28px auto; padding: 0 16px; display:grid; grid-template-columns: 1fr 340px; gap: 18px; }
    .card { background: var(--panel); border:1px solid #1f2633; border-radius: 14px; padding: 16px; }
    h1 { font-size: 22px; margin: 0 0 12px; }
    .row { display:flex; gap:10px; align-items:center; flex-wrap: wrap; }
    button, select { background:#202737; color:var(--ink); border:1px solid #2a3546; border-radius:10px;
      padding:10px 14px; cursor:pointer; font-weight:600; }
    button.primary { background:var(--accent); color:#081120; border-color:var(--accent); }
    button:disabled { opacity:.5; cursor:not-allowed; }
    .status { margin-left:auto; display:inline-flex; align-items:center; gap:8px; color:var(--muted); }
    .dot { width:10px; height:10px; border-radius:50%; background:#888; }
    .dot.idle { background:#888; } .dot.connecting{ background:#f1c40f; } .dot.connected{ background:var(--ok); } .dot.ended{ background:#d35454; }
    .log { font: 12px/1.4 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; white-space: pre-wrap;
      background:#0b0e15; border:1px solid #1e2431; border-radius:10px; padding:10px; height:420px; overflow:auto; }
    .portrait { width:100%; background:#000; border-radius:12px; overflow:hidden; display:grid; place-items:center; min-height:540px; }
    .hint { color: var(--muted); font-size: 13px; margin-top: 8px; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1 class="row">
        EmotiKnow — Emma (Voice Companion)
        <span class="status"><span id="statusDot" class="dot idle"></span><span id="statusTxt">idle</span></span>
      </h1>

      <div id="portrait" class="portrait">
        <!-- Your portrait image -->
        <img id="imgPortrait" src="/m.png" alt="Emma portrait" style="max-width:100%; height:auto; display:block;" />
        <!-- Audio sink for remote speech -->
        <audio id="remoteAudio" autoplay playsinline></audio>
      </div>

      <div class="row" style="margin-top:12px">
        <button id="testBtn">Test speaker</button>
        <button id="startBtn" class="primary">Start</button>
        <button id="hangBtn">Hang Up</button>
        <select id="voiceSel" title="voice">
          <option value="shimmer" selected>Shimmer (female, bright)</option>
          <option value="ballad">Ballad (feminine, lyrical)</option>
          <option value="verse">Verse (neutral, gentle)</option>
        </select>
      </div>
      <div class="hint">Tip: If you don’t hear Emma, click <b>Test speaker</b> once, then click <b>Start</b>.</div>
    </div>

    <div class="card">
      <div class="row" style="justify-content:space-between;">
        <div>Diagnostics</div>
        <div style="color:var(--muted); font-size:12px">model: gpt-4o-mini-realtime-preview</div>
      </div>
      <div id="log" class="log"></div>
    </div>
  </div>

<script>
const $ = sel => document.querySelector(sel);
const logBox = $('#log');
const statusDot = $('#statusDot');
const statusTxt  = $('#statusTxt');
const startBtn  = $('#startBtn');
const hangBtn   = $('#hangBtn');
const testBtn   = $('#testBtn');
const voiceSel  = $('#voiceSel');
const remoteAudio = $('#remoteAudio');

function log(s){ const at = new Date().toLocaleTimeString(); logBox.textContent += `[${at}] ${s}\n`; logBox.scrollTop = logBox.scrollHeight; }
function setStatus(state){
  statusDot.className = 'dot ' + state;
  statusTxt.textContent = state;
}

let pc = null;
let localStream = null;

function testSpeaker(){
  try{
    const ctx = new (window.AudioContext||window.webkitAudioContext)();
    const osc = ctx.createOscillator(); const g = ctx.createGain();
    osc.frequency.value = 880; g.gain.value = 0.05;
    osc.connect(g).connect(ctx.destination); osc.start();
    setTimeout(()=>{ osc.stop(); ctx.close(); }, 220);
    log('[speaker] test ping.');
  }catch(e){ log('[speaker] test failed: '+(e?.message||e)); }
}
testBtn.addEventListener('click', testSpeaker);

async function startSession(){
  if (pc) return;
  setStatus('connecting');
  log('[mic] requesting…');

  try {
    localStream = await navigator.mediaDevices.getUserMedia({ audio:true });
    log('[mic] granted.');
  } catch (e) {
    log('[mic] denied: ' + (e?.message || e));
    setStatus('idle'); return;
  }

  pc = new RTCPeerConnection();
  // Send mic upstream
  localStream.getTracks().forEach(tr => pc.addTrack(tr, localStream));
  // Receive remote audio downstream
  const remoteStream = new MediaStream();
  pc.ontrack = e => {
    e.streams[0].getAudioTracks().forEach(t => remoteStream.addTrack(t));
    remoteAudio.srcObject = remoteStream;
  };

  pc.onconnectionstatechange = () => {
    log('[pc] state: ' + pc.connectionState);
    if (pc.connectionState === 'connected') setStatus('connected');
    if (pc.connectionState === 'failed' || pc.connectionState === 'closed' || pc.connectionState === 'disconnected') {
      if (pc.connectionState !== 'connected') setStatus('ended');
    }
  };

  // Create SDP offer
  const offer = await pc.createOffer({ offerToReceiveAudio: true });
  await pc.setLocalDescription(offer);
  log('[sdp] local offer created.');

  // Fetch ephemeral token (GET) just for sanity/logging
  const voice = voiceSel.value || 'shimmer';
  log('[token] fetching…');
  const tokenR = await fetch(`/api/realtime-session?voice=${encodeURIComponent(voice)}`);
  if(!tokenR.ok){ log(`[token] error HTTP ${tokenR.status}`); throw new Error('token endpoint error'); }
  await tokenR.json(); // not used in this flow; POST route will do the real exchange
  log('[token] ok.');

  // Exchange SDP via our server (POST)
  log('[sdp] exchanging via /api/realtime-session (POST)…');
  const post = await fetch('/api/realtime-session', {
    method: 'POST',
    headers: { 'Content-Type':'application/json' },
    body: JSON.stringify({ sdp: offer.sdp, voice })
  });
  if(!post.ok){
    const t = await post.text().catch(()=> '');
    log(`[sdp] server POST failed: ${post.status} ${t}`);
    throw new Error('SDP exchange failed.');
  }
  const { answer } = await post.json();
  await pc.setRemoteDescription({ type:'answer', sdp: answer });
  log('[sdp] answer set. WebRTC completing…');
}

async function hangup(){
  if (pc) {
    try{ pc.close(); }catch{}
    pc = null;
  }
  if (localStream) {
    localStream.getTracks().forEach(t => t.stop());
    localStream = null;
  }
  setStatus('ended');
  log('[call] ended.');
}

startBtn.addEventListener('click', () => startSession().catch(e=>{ log('[error] '+(e?.message||e)); setStatus('ended'); }));
hangBtn.addEventListener('click', hangup);
</script>
</body>
</html>

<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>EmotiKnow — Emma (Voice Companion)</title>
<style>
  :root{
    --bg:#0b0f14;--panel:#111826;--stroke:#1b2537;--text:#eef3ff;--muted:#9fb0ca;
    --accent:#7c9cff;--ok:#79d08a;--err:#ff7e7e;--btn:#1e2738;--btn2:#242f44;
  }
  html,body{background:var(--bg);color:var(--text);font-family:Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial; margin:0}
  .wrap{max-width:1200px;margin:24px auto 56px;padding:0 16px}
  h1{margin:0 0 6px;font-size:clamp(22px,3.2vw,32px);font-weight:800}
  .muted{color:var(--muted);font-size:14px}
  .grid{display:grid;grid-template-columns:1.1fr .9fr;gap:16px;margin-top:16px}
  @media (max-width:980px){.grid{grid-template-columns:1fr}}
  .panel{background:var(--panel);border:1px solid var(--stroke);border-radius:12px;overflow:hidden}
  .head{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;border-bottom:1px solid var(--stroke)}
  .body{padding:12px}
  .vis{position:relative;width:100%;aspect-ratio:16/10;background:#0d1320;border-radius:10px;overflow:hidden}
  .portrait{position:absolute;inset:0;width:100%;height:100%;object-fit:cover;pointer-events:none}
  #mouth{position:absolute;inset:0;width:100%;height:100%;pointer-events:none}
  .cross{--s:20px;position:absolute;width:var(--s);height:var(--s);transform:translate(-50%,-50%);
         border:2px solid rgba(255,255,255,.8);border-radius:50%;background:rgba(255,84,84,.55);pointer-events:none}
  .row{display:flex;flex-wrap:wrap;gap:10px;align-items:center;margin-top:10px}
  button,select,input[type=range]{background:var(--btn);color:var(--text);border:1px solid #2a3750;border-radius:10px}
  button,select{padding:9px 12px;font-size:14px;cursor:pointer}
  button:hover{background:var(--btn2)}
  .primary{background:#6c63ff;border-color:#5b54ef} .danger{background:#3a2732;border-color:#58394b}
  .status{margin-left:auto;background:#172033;border-radius:9px;padding:6px 8px;color:var(--muted);font-size:13px}
  .status.ok{color:var(--ok)} .status.err{color:var(--err)}
  pre{background:#0b1120;border:1px solid var(--stroke);border-radius:10px;color:#cfe3ff;padding:12px;height:clamp(240px,38vh,420px);
      overflow:auto;margin:0;white-space:pre-wrap;font-family:ui-monospace,Menlo,Consolas,monospace;font-size:13px;line-height:1.35}
  .ctrl{display:flex;align-items:center;gap:8px}
  .ctrl label{font-size:12px;color:var(--muted)}
  .ctrl input[type=range]{height:6px;padding:0;width:140px;background:#0e1625}
  .meter{width:120px;height:8px;background:#0f1a2a;border-radius:6px;overflow:hidden;border:1px solid #1b2740}
  .bar{height:100%;width:0;background:linear-gradient(90deg,#3be2b9,#79d08a);transition:width .08s}
</style>
</head>
<body>
<div class="wrap">
  <h1>EmotiKnow — Emma (Voice Companion)</h1>
  <div class="muted">Click <b>Start</b> once to allow your microphone. Talk naturally; Emma replies in real time. Her portrait lip-syncs to the audio.</div>

  <div class="grid">
    <div class="panel">
      <div class="head">
        <div>Emma (portrait)</div>
        <div id="state" class="status">idle</div>
      </div>
      <div class="body">
        <div id="vis" class="vis" title="Click/drag to re-anchor mouth.">
          <img id="portrait" class="portrait" src="/Emma_EmotiKnow_Companion.png" alt="Emma" />
          <canvas id="mouth"></canvas>
          <div id="target" class="cross"></div>
        </div>

        <div class="row">
          <button id="start" class="primary">Start</button>
          <button id="hang" class="danger">Hang Up</button>

          <select id="voice">
            <option value="shimmer" selected>Shimmer (female, bright)</option>
            <option value="coral">Coral (female, clear)</option>
            <option value="sage">Sage (female, soft)</option>
            <option value="marin">Marin (female, warm)</option>
            <option value="ballad">Ballad (feminine, lyrical)</option>
            <option value="verse">Verse (neutral)</option>
            <option value="alloy">Alloy (neutral)</option>
            <option value="echo">Echo</option>
            <option value="ash">Ash</option>
            <option value="cedar">Cedar</option>
          </select>

          <button id="test">Test speaker</button>

          <div class="ctrl"><label>Lip size</label><input id="lipSize" type="range" min="50" max="160" value="100"></div>
          <div class="ctrl"><label>Sensitivity</label><input id="sens" type="range" min="50" max="200" value="100"></div>
          <div class="ctrl"><label>Gate</label><input id="gate" type="range" min="0" max="20" value="6"></div>

          <div class="ctrl" style="margin-left:auto">
            <label>VU</label>
            <div class="meter"><div id="vu" class="bar"></div></div>
          </div>
        </div>

        <div class="muted" style="margin-top:8px">
          If you don’t hear Emma, click <b>Test speaker</b>, then <b>Start</b> again (autoplay can be blocked). Click the portrait to re-anchor lips; your position is saved.
        </div>
      </div>
    </div>

    <div class="panel">
      <div class="head"><div>Diagnostics</div></div>
      <div class="body"><pre id="log"></pre></div>
    </div>
  </div>
</div>

<audio id="remote" autoplay playsinline></audio>

<script>
/* ---------------------- DOM ---------------------- */
const vis = document.getElementById('vis');
const img = document.getElementById('portrait');
const canvas = document.getElementById('mouth');
const ctx = canvas.getContext('2d', { alpha: true });
const target = document.getElementById('target');

const startBtn = document.getElementById('start');
const hangBtn  = document.getElementById('hang');
const voiceSel = document.getElementById('voice');
const testBtn  = document.getElementById('test');

const lipSize = document.getElementById('lipSize');
const sens    = document.getElementById('sens');
const gateCtl = document.getElementById('gate');
const vuBar   = document.getElementById('vu');

const stateEl = document.getElementById('state');
const logEl   = document.getElementById('log');
const remoteEl = document.getElementById('remote');

/* ---------------- Mouth anchor (image space) ---------------- */
const DEFAULT_MOUTH = { x: 523, y: 215 };
function getMouth(){
  try { const s = localStorage.getItem('emma_mouth_anchor'); if (s) return JSON.parse(s); } catch {}
  return { ...DEFAULT_MOUTH };
}
function saveMouth(p){ localStorage.setItem('emma_mouth_anchor', JSON.stringify(p)); log(`Saved mouth: x=${p.x}, y=${p.y}`); }
let mouthImg = getMouth();

/* ---------------- Layout helpers ---------------- */
function log(m){ const t = new Date().toLocaleTimeString(); logEl.textContent += `[${t}] ${m}\n`; logEl.scrollTop = logEl.scrollHeight; }
function setState(s, ok=false, err=false){ stateEl.textContent = s; stateEl.classList.toggle('ok', ok); stateEl.classList.toggle('err', err); }

function updateCanvasSize(){
  const r = vis.getBoundingClientRect();
  canvas.width  = Math.max(2, Math.floor(r.width  * devicePixelRatio));
  canvas.height = Math.max(2, Math.floor(r.height * devicePixelRatio));
  canvas.style.width  = r.width + 'px';
  canvas.style.height = r.height + 'px';
  drawMouth(0);
  placeTarget();
}
function placeTarget(){
  const css = imgToCss(mouthImg.x, mouthImg.y);
  target.style.left = css.x + 'px';
  target.style.top  = css.y + 'px';
}
function imgToCss(ix, iy){
  const r = vis.getBoundingClientRect();
  const W = r.width, H = r.height;
  const iw = img.naturalWidth || 1920, ih = img.naturalHeight || 1200;
  const ir = iw/ih, br = W/H;
  let dw, dh, ox, oy;
  if (ir > br){ dh = H; dw = H*ir; ox = (W - dw)/2; oy = 0; }
  else       { dw = W; dh = W/ir; ox = 0; oy = (H - dh)/2; }
  return { x: ox + ix * (dw/iw), y: oy + iy * (dh/ih) };
}
function cssToImg(cx, cy){
  const r = vis.getBoundingClientRect();
  const W = r.width, H = r.height;
  const iw = img.naturalWidth || 1920, ih = img.naturalHeight || 1200;
  const ir = iw/ih, br = W/H;
  let dw, dh, ox, oy;
  if (ir > br){ dh = H; dw = H*ir; ox = (W - dw)/2; oy = 0; }
  else       { dw = W; dh = W/ir; ox = 0; oy = (H - dh)/2; }
  return { x: (cx - ox) * (iw/dw), y: (cy - oy) * (ih/dh) };
}
/* anchor picking */
let dragging = false;
vis.addEventListener('pointerdown', e => { dragging = true; setAnchor(e); });
vis.addEventListener('pointermove', e => { if (dragging) setAnchor(e); });
window.addEventListener('pointerup', () => dragging = false);
function setAnchor(e){
  const r = vis.getBoundingClientRect();
  const cx = e.clientX - r.left, cy = e.clientY - r.top;
  mouthImg = cssToImg(cx, cy);
  saveMouth(mouthImg); placeTarget();
}

/* ---------------- Realtime + audio analyzer ---------------- */
let pc = null, localStream = null, analyser = null, raf = null, audioCtx = null;
let env = 0; // smoothed envelope for mouth openness

async function start(){
  try{
    await resumeAudio();
    setState('requesting mic…'); log('Requesting microphone…');
    localStream = await navigator.mediaDevices.getUserMedia({ audio: true });

    const v = voiceSel.value || 'shimmer';
    const tokRes = await fetch(`/api/realtime-session?voice=${encodeURIComponent(v)}`);
    if (!tokRes.ok){ throw new Error(`Token endpoint ${tokRes.status}: ${await tokRes.text()}`); }
    const token = await tokRes.json(); log(`Token response status: ${tokRes.status}`);

    pc = new RTCPeerConnection();
    pc.onconnectionstatechange = () => {
      log(`pc state: ${pc.connectionState}`);
      if (['disconnected','failed','closed'].includes(pc.connectionState)) { setState('ended'); cleanup(); }
    };
    pc.ontrack = (e) => {
      remoteEl.srcObject = e.streams[0];
      setupAnalyzer(remoteEl);
      log('Remote audio stream received.');
    };
    localStream.getTracks().forEach(t => pc.addTrack(t, localStream));

    const offer = await pc.createOffer({ offerToReceiveAudio: true });
    await pc.setLocalDescription(offer);
    setState('connecting');

    const url = `https://api.openai.com/v1/realtime?model=${encodeURIComponent(token.model || 'gpt-4o-mini-realtime-preview')}`;
    log(`POSTing SDP to: ${url}`);
    const sdpRes = await fetch(url, {
      method:'POST',
      headers:{
        'Authorization': `Bearer ${token.client_secret.value}`,
        'Content-Type': 'application/sdp',
        'OpenAI-Beta': 'realtime=v1'
      },
      body: offer.sdp
    });
    log(`SDP POST status: ${sdpRes.status}`);
    if (!sdpRes.ok){ throw new Error(`SDP exchange failed: ${await sdpRes.text()}`); }
    const answer = { type:'answer', sdp: await sdpRes.text() };
    await pc.setRemoteDescription(answer);

    setState('connected', true);
    log('Session established.');
  } catch(err){
    console.error(err); log('Error: ' + err.message); setState('error', false, true);
    cleanup();
  }
}
function hang(){ log('Call ended. (user)'); setState('ended'); cleanup(); }
function cleanup(){
  if (pc){ try{ pc.close(); }catch{} pc=null; }
  if (localStream){ localStream.getTracks().forEach(t => t.stop()); localStream=null; }
  stopAnalyzer();
}
async function testSpeaker(){
  await resumeAudio();
  const ctx = new (window.AudioContext||window.webkitAudioContext)();
  const o = ctx.createOscillator(), g = ctx.createGain(); g.gain.value = .05;
  o.frequency.value = 880; o.connect(g).connect(ctx.destination); o.start();
  await new Promise(r=>setTimeout(r,250)); o.stop(); await ctx.close();
}
async function resumeAudio(){
  if (!audioCtx) return;
  if (audioCtx.state === 'suspended'){ try{ await audioCtx.resume(); }catch{} }
}

/* --------- Analyzer + lip drawing --------- */
function setupAnalyzer(audioEl){
  stopAnalyzer();
  audioCtx = new (window.AudioContext||window.webkitAudioContext)();
  const src = audioCtx.createMediaElementSource(audioEl);
  analyser = audioCtx.createAnalyser();
  analyser.fftSize = 2048;
  src.connect(analyser); analyser.connect(audioCtx.destination);
  env = 0;
  tick();
}
function stopAnalyzer(){ if (raf) cancelAnimationFrame(raf); raf = null; drawMouth(0); vuBar.style.width='0%'; if (audioCtx){ try{audioCtx.close();}catch{} } audioCtx=null; analyser=null; }

const tmp = new Uint8Array(2048);
function tick(){
  if (!analyser){ drawMouth(0); return; }
  analyser.getByteTimeDomainData(tmp);

  // RMS around 128 baseline
  let sum=0; for (let i=0;i<tmp.length;i++){ const d=tmp[i]-128; sum+=d*d; }
  const rms = Math.sqrt(sum/tmp.length); // ~0..90
  // normalize -> ~0..1 then apply sensitivity
  const sensitivity = Number(sens.value)/100; // 1.0 default
  let x = (rms/35) * sensitivity;
  // gate to kill tiny background noise
  const gate = Number(gateCtl.value)/100; // 0..0.2
  x = Math.max(0, x - gate);
  x = Math.min(1, x);

  // smoothed envelope (attack faster than release)
  const attack = 0.18, release = 0.28;
  env += (x - env) * (x > env ? attack : release);

  // VU meter
  vuBar.style.width = (Math.min(1, env)*100).toFixed(0)+'%';

  drawMouth(env);
  raf = requestAnimationFrame(tick);
}

/* --------- Drawing (smaller & subtle) --------- */
function drawMouth(open){
  const r = vis.getBoundingClientRect();
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // Map anchor to canvas pixels
  const css = imgToCss(mouthImg.x, mouthImg.y);
  const px = css.x * (canvas.width / r.width);
  const py = css.y * (canvas.height/ r.height);

  // Tunables (small by default; scale by slider)
  const scale = Number(lipSize.value)/100; // 1.0 default
  const baseW = 16 * devicePixelRatio * scale;  // narrower
  const baseH =  6 * devicePixelRatio * scale;
  const amp   = 14 * devicePixelRatio * scale;  // opening range
  const mw = baseW;
  const mh = baseH + amp * open;

  ctx.save();
  ctx.translate(px, py);

  // inner mouth (very subtle, not cartoon red)
  ctx.fillStyle = 'rgba(210, 90, 100, 0.65)';   // mellow rose
  drawOval(ctx, 0, 0, mw, mh);
  ctx.fill();

  // soft highlight to keep it natural
  const g = ctx.createRadialGradient(0,0,2, 0,0, mw);
  g.addColorStop(0,'rgba(240,170,180,0.50)');
  g.addColorStop(1,'rgba(200, 70, 90, 0.12)');
  ctx.fillStyle = g;
  drawOval(ctx, 0, 0, mw*0.88, mh*0.78);
  ctx.fill();

  // faint edge
  ctx.strokeStyle = 'rgba(0,0,0,0.18)';
  ctx.lineWidth = 1.5 * devicePixelRatio;
  drawOval(ctx, 0, 0, mw, mh);
  ctx.stroke();

  ctx.restore();
}
function drawOval(c, cx, cy, rx, ry){ c.beginPath(); c.ellipse(cx, cy, rx, ry, 0, 0, Math.PI*2); c.closePath(); }

/* ---------------- Events & init ---------------- */
startBtn.addEventListener('click', start);
hangBtn.addEventListener('click', hang);
testBtn.addEventListener('click', testSpeaker);
window.addEventListener('resize', updateCanvasSize);
img.addEventListener('load', () => { updateCanvasSize(); placeTarget(); });

function init(){ updateCanvasSize(); placeTarget(); setState('idle'); log('Ready. Click Start; if muted, Test speaker then Start again.'); }
init();
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>EmotiKnow — Mouth Sync Preview</title>
  <link rel="stylesheet" href="/style.css" />
  <style>
    body { font-family: system-ui, sans-serif; margin: 0; padding: 24px; }
    .wrap { max-width: 900px; margin: 0 auto; display: grid; gap: 16px; }
    .panel { border: 1px solid #e5e7eb; border-radius: 16px; padding: 16px; }
    .stage { position: relative; width: 640px; height: 360px; margin: 0 auto; }
    .stage img { width: 100%; height: 100%; object-fit: cover; border-radius: 16px; }
    .mouth { position: absolute; pointer-events: none; transform-origin: center; }
    button { background: #111; color: #fff; border: 0; padding: 10px 16px; border-radius: 14px; }
    input[type="range"] { width: 100%; }
    .grid2 { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    label { font-size: 12px; opacity: .8; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>EmotiKnow — Mouth Sync Preview</h1>

    <div class="panel">
      <textarea id="text" rows="3" style="width:100%; border-radius:12px; padding:12px;">
Hi, I’m Emma. I can talk and move my mouth in sync. How can I help?
      </textarea>
      <div style="display:flex; gap:12px; align-items:center; margin-top:10px;">
        <button id="speak">Speak</button>
        <span style="font-size:12px; opacity:.7;">Viseme: <b id="viseme">X</b></span>
      </div>
    </div>

    <div class="panel">
      <div class="grid2">
        <div>
          <label>Image URL</label>
          <input id="imgUrl" value="/emma.jpg" style="width:100%; padding:8px; border-radius:10px; border:1px solid #e5e7eb;" />
        </div>
        <div></div>

        <div>
          <label>Mouth X: <span id="lx">165</span>px</label>
          <input type="range" id="mx" min="0" max="500" value="165">
        </div>
        <div>
          <label>Mouth Y: <span id="ly">270</span>px</label>
          <input type="range" id="my" min="0" max="500" value="270">
        </div>
        <div>
          <label>Scale: <span id="ls">1.00</span></label>
          <input type="range" id="ms" min="0.5" max="2" step="0.01" value="1.00">
        </div>
        <div>
          <label>Rotate: <span id="lr">0</span>°</label>
          <input type="range" id="mr" min="-20" max="20" value="0">
        </div>
      </div>

      <div class="stage">
        <img id="bg" src="/emma.jpg" alt="Emma">
        <!-- SVG mouth overlay -->
        <div class="mouth" id="mouth" style="left:165px; top:270px; transform: scale(1) rotate(0deg);">
          <svg width="140" height="100" viewBox="50 85 100 70">
            <path id="mouthPath" d="M60 112 Q100 115 140 112 Q100 118 60 112 Z" fill="#8b1a1a" stroke="#5f0f0f" stroke-width="2"/>
          </svg>
        </div>
      </div>
    </div>
  </div>

  <script>
    const pathFor = (v) => {
      switch (v) {
        case "M": return "M60 110 Q100 120 140 110 Q100 118 60 110 Z";
        case "F": return "M60 108 Q100 112 140 108 Q100 120 60 108 Z";
        case "L": return "M60 113 Q100 130 140 113 Q100 132 60 113 Z";
        case "S": return "M60 112 Q100 118 140 112 Q100 120 60 112 Z";
        case "A": return "M60 95 Q100 145 140 95 Q100 165 60 95 Z";
        case "E": return "M60 105 Q100 120 140 105 Q100 130 60 105 Z";
        case "I": return "M85 102 Q100 135 115 102 Q100 150 85 102 Z";
        case "O": return "M80 100 Q100 145 120 100 Q100 155 80 100 Z";
        case "U": return "M82 96 Q100 148 118 96 Q100 160 82 96 Z";
        default:  return "M60 112 Q100 115 140 112 Q100 118 60 112 Z";
      }
    };

    const mouth = document.getElementById("mouth");
    const mouthPath = document.getElementById("mouthPath");
    const speakBtn = document.getElementById("speak");
    const txt = document.getElementById("text");
    const visemeEl = document.getElementById("viseme");

    // sliders
    const mx = document.getElementById("mx");
    const my = document.getElementById("my");
    const ms = document.getElementById("ms");
    const mr = document.getElementById("mr");
    const lx = document.getElementById("lx");
    const ly = document.getElementById("ly");
    const ls = document.getElementById("ls");
    const lr = document.getElementById("lr");
    const imgUrl = document.getElementById("imgUrl");
    const bg = document.getElementById("bg");

    function updateOverlay() {
      mouth.style.left = mx.value + "px";
      mouth.style.top = my.value + "px";
      mouth.style.transform = `scale(${ms.value}) rotate(${mr.value}deg)`;
      lx.textContent = mx.value; ly.textContent = my.value; ls.textContent = (+ms.value).toFixed(2); lr.textContent = mr.value;
    }
    mx.oninput = my.oninput = ms.oninput = mr.oninput = updateOverlay;
    imgUrl.onchange = () => { bg.src = imgUrl.value; };

    function fakeTimeline(text) {
      const clean = text.trim().replace(/\s+/g, " ");
      const groups = Math.max(8, Math.min(60, Math.ceil(clean.length / 4)));
      const seq = ["M","A","E","I","O","U","S","L","F","X"];
      return Array.from({length: groups}, (_, i) => ({ t: i * 110, v: seq[i % seq.length] }));
    }

    let raf = null, start = 0, playing = false;

    function animate(marks) {
      start = performance.now();
      const step = () => {
        const elapsed = performance.now() - start;
        let v = "X";
        for (let i = 0; i < marks.length; i++) { if (elapsed >= marks[i].t) v = marks[i].v; else break; }
        mouthPath.setAttribute("d", pathFor(v));
        visemeEl.textContent = v;
        if (playing) raf = requestAnimationFrame(step);
      };
      if (raf) cancelAnimationFrame(raf);
      raf = requestAnimationFrame(step);
    }

    speakBtn.onclick = async () => {
      playing = true;
      const marks = fakeTimeline(txt.value);
      animate(marks);

      const synth = window.speechSynthesis;
      if (synth) {
        try { synth.cancel(); } catch(e) {}
        const u = new SpeechSynthesisUtterance(txt.value);
        u.rate = 1.0;
        synth.speak(u);
        await new Promise(res => { u.onend = res; u.onerror = res; });
      } else {
        const est = Math.max(1500, Math.min(8000, txt.value.length * 50));
        await new Promise(res => setTimeout(res, est));
      }

      playing = false;
      mouthPath.setAttribute("d", pathFor("X"));
      visemeEl.textContent = "X";
    };

    updateOverlay();
  </script>
</body>
</html>

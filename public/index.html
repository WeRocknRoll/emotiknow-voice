<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta
    name="viewport"
    content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>EmotiKnow — Emma (Voice Companion)</title>
  <style>
    :root {
      --bg: #0e1117;
      --panel: #111827;
      --text: #e5e7eb;
      --muted: #9ca3af;
      --accent: #8b5cf6;
      --btn: #7c3aed;
      --btn-hover: #6d28d9;
      --warn: #f59e0b;
      --ok: #34d399;
      --error: #f87171;
      --log-bg: #0b1220;
    }
    html, body {
      margin: 0; padding: 0;
      background: var(--bg); color: var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    .wrap {
      max-width: 1100px;
      margin: 24px auto;
      padding: 16px;
    }
    .card {
      background: var(--panel);
      border-radius: 16px;
      padding: 24px;
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
    }
    h1 {
      margin: 0 0 18px;
      font-size: 40px;
      letter-spacing: .2px;
    }
    .muted { color: var(--muted); }
    .row { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; margin: 12px 0 8px; }
    select, button {
      appearance: none;
      border: 0;
      border-radius: 12px;
      padding: 12px 16px;
      font-weight: 600;
    }
    button {
      background: var(--btn);
      color: white;
      cursor: pointer;
    }
    button:hover { background: var(--btn-hover); }
    button.secondary { background: #374151; }
    .status { margin-left: auto; font-weight: 700; }
    .status.ok { color: var(--ok); }
    .status.error { color: var(--error); }
    .log {
      background: var(--log-bg);
      border-radius: 12px;
      padding: 16px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 14px;
      height: 420px;
      overflow: auto;
      line-height: 1.45;
      border: 1px solid rgba(255,255,255,.05);
    }
    .tip { color: var(--muted); font-size: 13px; margin-top: 10px; }
    .sr { position: absolute; left: -10000px; top: auto; width: 1px; height: 1px; overflow: hidden; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>EmotiKnow — Emma (Voice Companion)</h1>
      <p class="muted">Click <strong>Start</strong> once to allow your microphone. Talk naturally; Emma replies in real time.</p>

      <div class="row">
        <button id="start">Start</button>
        <button id="hangup" class="secondary">Hang Up</button>

        <select id="voice">
          <!-- defaults to shimmer; server clamps unknowns -->
          <option value="shimmer" selected>Shimmer (female, bright)</option>
          <option value="ballad">Ballad (feminine, lyrical)</option>
          <option value="marin">Marin (female, warm)</option>
          <option value="coral">Coral (female, clear)</option>
          <option value="verse">Verse (neutral)</option>
          <option value="alloy">Alloy (neutral)</option>
          <option value="ash">Ash</option>
          <option value="echo">Echo</option>
          <option value="sage">Sage</option>
          <option value="cedar">Cedar</option>
        </select>

        <button id="test" class="secondary">Test speaker</button>
        <span id="status" class="status">idle</span>
      </div>

      <div id="log" class="log" aria-live="polite"></div>
      <p class="tip">
        Tip: If you don’t hear Emma, click <strong>Test speaker</strong>, then click <strong>Start</strong> again (browsers sometimes block autoplay).
        If Emma goes quiet, just speak again—she’ll pick it up.
      </p>

      <audio id="remote" autoplay class="sr"></audio>
    </div>
  </div>

  <script>
    const logEl = document.getElementById("log");
    const statusEl = document.getElementById("status");
    const remoteAudio = document.getElementById("remote");
    const startBtn = document.getElementById("start");
    const hangBtn = document.getElementById("hangup");
    const voiceSel = document.getElementById("voice");
    const testBtn = document.getElementById("test");

    let pc = null;
    let localStream = null;
    let restarting = false;

    function log(msg) {
      const t = new Date().toLocaleTimeString();
      logEl.textContent += `[${t}] ${msg}\n`;
      logEl.scrollTop = logEl.scrollHeight;
    }
    function setStatus(s, type="") {
      statusEl.textContent = s;
      statusEl.className = "status " + (type || "");
    }

    // Simple test beep to unlock audio
    testBtn.addEventListener("click", async () => {
      try {
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const osc = ctx.createOscillator();
        osc.frequency.value = 880;
        osc.connect(ctx.destination);
        osc.start();
        setTimeout(() => { osc.stop(); ctx.close(); }, 180);
        log("Test speaker beep played.");
      } catch (e) {
        log("Test speaker failed: " + e.message);
      }
    });

    hangBtn.addEventListener("click", () => hangup());
    startBtn.addEventListener("click", () => start());

    async function start() {
      try {
        setStatus("requesting mic…");
        log("Requesting microphone…");
        localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        log("Mic granted.");

        // Get a fresh server token
        const voice = voiceSel.value || "shimmer";
        const tokenRes = await fetch(`/api/realtime-session?voice=${encodeURIComponent(voice)}`);
        const tokenText = await tokenRes.text();
        log(`Token response status: ${tokenRes.status}`);

        if (!tokenRes.ok) {
          // Surface the body so we can see real errors
          log("Token fetch failed body: " + tokenText);
          setStatus("error", "error");
          return;
        }

        let token;
        try { token = JSON.parse(tokenText); }
        catch { log("Error: Token endpoint returned non-JSON."); setStatus("error", "error"); return; }

        // Create peer connection
        pc = new RTCPeerConnection();
        pc.ontrack = (e) => {
          // Play OpenAI audio
          remoteAudio.srcObject = e.streams[0];
        };

        pc.onconnectionstatechange = () => {
          log("pc state: " + pc.connectionState);
          if (["disconnected", "failed"].includes(pc.connectionState)) {
            // Restart once, cleanly
            if (!restarting) {
              restarting = true;
              log("Connection dropped — restarting…");
              hangup();
              setTimeout(() => { restarting = false; start(); }, 500);
            }
          }
        };

        // Add mic tracks
        localStream.getTracks().forEach(t => pc.addTrack(t, localStream));

        // Data channel (optional for future features)
        pc.createDataChannel("oai-events");

        // Offer
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);

        // POST SDP to OpenAI Realtime endpoint
        const sdpRes = await fetch(
          `https://api.openai.com/v1/realtime?model=gpt-4o-mini-realtime-preview`,
          {
            method: "POST",
            headers: {
              Authorization: `Bearer ${token.client_secret?.value}`,
              "Content-Type": "application/sdp",
              "OpenAI-Beta": "realtime=v1",
            },
            body: offer.sdp,
          }
        );

        const answerSdp = await sdpRes.text();
        log("SDP POST status: " + sdpRes.status);

        if (!sdpRes.ok) {
          log("SDP POST failed body: " + answerSdp);
          setStatus("error", "error");
          return;
        }

        await pc.setRemoteDescription({ type: "answer", sdp: answerSdp });
        setStatus("live (hands-free)", "ok");
        log(`Session established on ${token.model}. Voice: ${token.voice}.`);
        log("Remote audio playback started.");
      } catch (err) {
        log("Start error: " + (err?.message || String(err)));
        setStatus("error", "error");
      }
    }

    function hangup() {
      if (pc) {
        try { pc.close(); } catch {}
        pc = null;
      }
      if (localStream) {
        localStream.getTracks().forEach(t => t.stop());
        localStream = null;
      }
      setStatus("ended");
      log("Call ended.");
    }
  </script>
</body>
</html>

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>EmotiKnow — Emma (Voice Companion)</title>
  <style>
    :root{
      --bg:#0f1117; --panel:#151823; --ink:#e6e8ef; --muted:#9aa3b2; --accent:#8ab4ff;
      --ok:#22c55e; --warn:#f59e0b; --err:#ef4444;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; background:var(--bg); color:var(--ink);
      font:500 15px/1.45 system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial,"Apple Color Emoji","Segoe UI Emoji";
      display:grid; place-items:start center; padding:16px;
    }
    .wrap{width:min(1200px,100%); display:grid; gap:16px;}
    h1{margin:0 4px 4px; font-weight:800; letter-spacing:.2px}

    .row{display:grid; grid-template-columns:1fr 360px; gap:14px}
    @media (max-width:980px){ .row{grid-template-columns:1fr} }

    .panel{
      background:var(--panel); border:1px solid #202937; border-radius:14px; padding:12px;
      box-shadow:0 12px 40px rgba(0,0,0,.35);
    }

    /* Stage fits viewport: no zoom needed */
    .stage{
      position:relative; width:100%;
      max-height:70vh; /* <= key line */
      display:grid; place-items:center; overflow:hidden; background:#000;
      border-radius:10px;
    }
    .portrait{
      max-width:100%; max-height:100%; width:100%; height:auto; object-fit:contain; display:block;
      user-select:none; pointer-events:auto;
    }
    .mouth{
      position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);
      width:260px; pointer-events:none; image-rendering:auto; opacity:.98;
    }
    .overlayTag{
      position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);
      background:rgba(0,0,0,.35); color:var(--ink); padding:4px 8px; border-radius:8px; pointer-events:none;
      font-weight:700;
    }

    .controls{display:grid; gap:10px}
    .controls .row2{display:grid; grid-template-columns:1fr 1fr; gap:10px}
    .controls button{
      appearance:none; border:1px solid #263146; background:#111827; color:var(--ink);
      padding:12px 14px; border-radius:12px; font-weight:700; letter-spacing:.2px; cursor:pointer;
    }
    .controls button.primary{ background:#1e293b; border-color:#2b3b56 }
    .controls select, .controls input[type="range"]{ width:100%; accent-color:var(--accent) }
    .label{display:flex; justify-content:space-between; color:var(--muted)}
    .vu{width:100%; height:8px; background:#0b1020; border-radius:8px; overflow:hidden; box-shadow:inset 0 0 0 1px #1a2438}
    .vu>i{display:block; height:100%; width:0%; background:linear-gradient(90deg,#22c55e,#f59e0b,#ef4444)}
    .diag{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,"Liberation Mono",monospace; white-space:pre-wrap; background:#0b1020; color:#cbd5e1; padding:10px; border-radius:12px; height:200px; overflow:auto; border:1px solid #1a2438}
    .tip{color:var(--muted)}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>EmotiKnow — Emma (Voice Companion)</h1>

    <div class="row">
      <div class="panel stage" id="stage">
        <img id="portrait" class="portrait" src="/m.png" alt="Emma"/>
        <img id="mouth" class="mouth" src="/mouth/say.png" alt="mouth"/>
        <div id="overlayTag" class="overlayTag">mouth overlay</div>
      </div>

      <div class="panel controls">
        <div class="row2">
          <button id="startBtn" class="primary">Start</button>
          <button id="hangBtn">Hang Up</button>
        </div>

        <div>
          <div class="label"><span>Target width (mouth)</span><span id="wLbl">260 px</span></div>
          <input id="widthSlider" type="range" min="80" max="640" value="260"/>
        </div>
        <div>
          <div class="label"><span>Smooth (higher = slower)</span><span id="smoothLbl">0.85</span></div>
          <input id="smoothSlider" type="range" min="0" max="1" step="0.01" value="0.85"/>
        </div>
        <div>
          <div class="label"><span>Gate (ignore background)</span><span id="gateLbl">0.15</span></div>
          <input id="gateSlider" type="range" min="0" max="0.6" step="0.01" value="0.15"/>
        </div>
        <div>
          <div class="label"><span>Voice “personality”</span></div>
          <select id="persona">
            <option value="ballad">Ballad (warm)</option>
            <option value="shimmer" selected>Shimmer (bright)</option>
            <option value="soft">Soft (gentle)</option>
          </select>
        </div>
        <div>
          <div class="label"><span>VU</span></div>
          <div class="vu"><i id="vuBar"></i></div>
        </div>

        <div class="tip">
          Tip: Click Emma’s <b>real mouth</b> once to anchor the overlay. The position & sizing are saved per browser.
        </div>
        <div id="diag" class="diag"></div>
      </div>
    </div>
  </div>

  <script>
    const $ = (id)=>document.getElementById(id);
    const log = (...a)=>{ diag.textContent += a.join(' ') + "\\n"; diag.scrollTop = diag.scrollHeight; }

    const stage=$("stage"), portrait=$("portrait"), mouth=$("mouth"), overlayTag=$("overlayTag");
    const startBtn=$("startBtn"), hangBtn=$("hangBtn");
    const widthSlider=$("widthSlider"), wLbl=$("wLbl");
    const smoothSlider=$("smoothSlider"), smoothLbl=$("smoothLbl");
    const gateSlider=$("gateSlider"), gateLbl=$("gateLbl");
    const vuBar=$("vuBar"), persona=$("persona"), diag=$("diag");

    const anchorKey="emma_anchor_v1";
    let anchor = JSON.parse(localStorage.getItem(anchorKey) || "null") || {x:.52,y:.58};
    let mouthW = parseInt(widthSlider.value,10);

    function layoutMouth(){
      mouth.style.width = mouthW+"px";
      if(!portrait.naturalWidth){ return; }
      mouth.style.left = (anchor.x*100).toFixed(3)+"%";
      mouth.style.top  = (anchor.y*100).toFixed(3)+"%";
      mouth.style.transform = "translate(-50%,-50%)";
    }
    layoutMouth();
    window.addEventListener("resize", layoutMouth);
    portrait.addEventListener("load", layoutMouth);

    portrait.addEventListener("click",(e)=>{
      const r=portrait.getBoundingClientRect();
      anchor={ x:(e.clientX-r.left)/r.width, y:(e.clientY-r.top)/r.height };
      localStorage.setItem(anchorKey, JSON.stringify(anchor));
      layoutMouth();
      log("[anchor] saved x="+anchor.x.toFixed(3)+", y="+anchor.y.toFixed(3));
    });

    widthSlider.addEventListener("input",()=>{ mouthW=parseInt(widthSlider.value,10); wLbl.textContent=mouthW+" px"; layoutMouth(); });
    smoothSlider.addEventListener("input",()=>{ smoothLbl.textContent=parseFloat(smoothSlider.value).toFixed(2); });
    gateSlider.addEventListener("input",()=>{ gateLbl.textContent=parseFloat(gateSlider.value).toFixed(2); });

    // Preload frames
    const frames = ["f","p","o","g","v","i","l","u","say"].map(c=>`/mouth/${c}.png`);
    let loaded=0; frames.forEach(src=>{ const i=new Image(); i.onload=()=>{ if(++loaded===frames.length) log("[frames] loaded 9/9"); }; i.src=src; });

    let pc, localStream, remoteStream, vuRAF;

    function currentPersona(){
      const p = persona.value;
      if(p==="ballad") return {voice:"ballad", instructions:"Warm, kind, supportive. Keep replies short and encouraging."};
      if(p==="soft")   return {voice:"soft",   instructions:"Soft and gentle. Calming pace. Empathetic, reassuring."};
      return {voice:"shimmer", instructions:"Friendly, upbeat, caring. Smile in your voice."};
    }

    async function startCall(){
      try{
        startBtn.disabled=true; hangBtn.disabled=false; diag.textContent=""; log("[app] ready.");
        log("[mic] requesting…");
        localStream = await navigator.mediaDevices.getUserMedia({audio:true});
        log("[mic] granted.");

        log("[token] fetching…");
        const p=currentPersona();
        const tokenRes = await fetch("/api/realtime-session",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({voice:p.voice, instructions:p.instructions})});
        if(!tokenRes.ok){ log("[error] token http "+tokenRes.status+"\\n"+(await tokenRes.text())); cleanup(true); return; }
        const token = await tokenRes.json(); log("[token] ok.");

        pc = new RTCPeerConnection();
        // send mic
        localStream.getTracks().forEach(t=>pc.addTrack(t, localStream));

        // receive Emma audio
        remoteStream = new MediaStream();
        const audioEl = new Audio(); audioEl.autoplay=true; audioEl.srcObject = remoteStream;
        pc.ontrack = (ev)=>{ ev.streams[0].getAudioTracks().forEach(tr=>remoteStream.addTrack(tr)); };

        log("[sdp] exchanging via /v1/realtime (POST)…");
        const offer = await pc.createOffer({offerToReceiveAudio:true, offerToReceiveVideo:false});
        await pc.setLocalDescription(offer);
        const resp = await fetch("https://api.openai.com/v1/realtime?model=gpt-4o-mini-realtime-preview",{
          method:"POST",
          headers:{Authorization:`Bearer ${token.client_secret.value}`,"Content-Type":"application/sdp"},
          body:offer.sdp
        });
        const answerSDP = await resp.text();
        await pc.setRemoteDescription({type:"answer", sdp:answerSDP});
        log("[sdp] handshake complete.");
        pc.onconnectionstatechange = ()=>log("[pc] state: "+pc.connectionState);

        // ---- REMOTE VU (Emma drives lips) ----
        const audioCtx = new (window.AudioContext||window.webkitAudioContext)();
        const remoteSrc = audioCtx.createMediaStreamSource(remoteStream);
        const analyser = audioCtx.createAnalyser();
        analyser.fftSize = 512;
        remoteSrc.connect(analyser);
        const data = new Uint8Array(analyser.frequencyBinCount);
        let vu=0;

        function tickVU(){
          analyser.getByteTimeDomainData(data);
          let sum=0; for(let i=0;i<data.length;i++){ const v=(data[i]-128)/128; sum+=v*v; }
          const rms = Math.sqrt(sum/data.length); // ~0..0.7

          const smooth=parseFloat(smoothSlider.value);
          const gate=parseFloat(gateSlider.value);
          vu = vu*smooth + rms*(1-smooth);

          const shown = Math.max(0, vu - gate) / (0.6 - gate);
          const a = Math.max(0, Math.min(1, shown));
          vuBar.style.width = (a*100).toFixed(1)+"%";

          let frame;
          if (a < 0.02) frame = "/mouth/f.png";
          else if (a < 0.06) frame = "/mouth/p.png";
          else if (a < 0.12) frame = "/mouth/o.png";
          else if (a < 0.20) frame = "/mouth/g.png";
          else if (a < 0.28) frame = "/mouth/v.png";
          else if (a < 0.36) frame = "/mouth/i.png";
          else if (a < 0.46) frame = "/mouth/l.png";
          else if (a < 0.58) frame = "/mouth/u.png";
          else frame = "/mouth/say.png";
          if (!mouth.src.endsWith(frame)) mouth.src = frame;

          vuRAF = requestAnimationFrame(tickVU);
        }
        tickVU();

        // Hide the overlay tag after a moment
        setTimeout(()=>overlayTag.style.display="none", 2000);

      }catch(err){
        log("[ERROR] "+(err?.message||err));
        cleanup(true);
      }
    }

    function cleanup(showReady){
      try{ if(vuRAF) cancelAnimationFrame(vuRAF); }catch{}
      try{ if(pc){ pc.ontrack=null; pc.close(); } }catch{}
      pc=null;
      try{ if(localStream){ localStream.getTracks().forEach(t=>t.stop()); } }catch{}
      localStream=null; remoteStream=null;
      if(showReady) log("[call] ended.");
      startBtn.disabled=false; hangBtn.disabled=true;
    }

    startBtn.addEventListener("click", startCall);
    hangBtn.addEventListener("click", ()=>cleanup(true));
  </script>
</body>
</html>

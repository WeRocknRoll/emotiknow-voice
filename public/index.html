<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>EmotiKnow Emma — Smooth Mouth Crossfade</title>
<style>
  :root { color-scheme: dark; }
  body { margin:0; background:#0b0f14; color:#eaf0f7; font:16px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; }
  .wrap { max-width:980px; margin:24px auto; padding:0 16px; }
  h1 { margin:0 0 14px; }
  .row { display:flex; gap:12px; align-items:center; flex-wrap:wrap; margin:10px 0; }
  textarea, input[type="text"] { width:100%; background:#0a0f14; color:#eaf0f7; border:1px solid #1b2632; border-radius:10px; padding:10px; }
  button { background:#0f62fe; color:#fff; border:0; padding:10px 16px; border-radius:10px; font-weight:600; cursor:pointer; }
  input[type="range"] { width:260px; }
  .stage { position:relative; width:640px; height:360px; border-radius:14px; overflow:hidden; background:#000; }
  .stage img#bg { width:100%; height:100%; object-fit:cover; display:block; }

  /* Mouth container positioned by sliders; transform applies to container */
  #mouth {
    position:absolute; left:260px; top:98px;
    width:300px; height:160px;
    transform-origin:center center;
    transform:scale(.50) rotate(-1deg);
    pointer-events:none;
  }
  /* The two layers used for crossfade */
  .layer {
    position:absolute; inset:0;
    opacity:0;
    transition:opacity 120ms linear;
  }
  .layer img {
    position:absolute; inset:0; width:100%; height:100%;
    image-rendering:auto;
    /* CLEAN edges: no multiply; tiny soft mask to hide seams */
    mix-blend-mode:normal;
    -webkit-mask-image: radial-gradient(80% 60% at 50% 55%, rgba(0,0,0,1) 65%, rgba(0,0,0,0) 100%);
            mask-image: radial-gradient(80% 60% at 50% 55%, rgba(0,0,0,1) 65%, rgba(0,0,0,0) 100%);
  }
</style>
</head>
<body>
<div class="wrap">
  <h1>EmotiKnow Emma — Smooth Mouth Crossfade</h1>

  <div class="stage">
    <img id="bg" src="/emma.jpg" alt="Emma" />
    <!-- Mouth overlay (dual layers for crossfade) -->
    <div id="mouth">
      <div id="L1" class="layer" style="opacity:1"><img src="/mouth/X.png" alt=""></div>
      <div id="L2" class="layer" style="opacity:0"><img src="/mouth/X.png" alt=""></div>
    </div>
  </div>

  <div class="row"><div style="min-width:90px">Script</div><textarea id="text" rows="4">Hi, I’m Emma. I can talk and move my mouth in sync. How can I help?</textarea></div>
  <div class="row">
    <button id="speak">Speak</button>
    <div>Viseme: <b id="viseme">X</b></div>
  </div>

  <div class="row"><div style="min-width:90px">Image URL</div><input id="imgUrl" type="text" value="/emma.jpg" /></div>
  <div class="row"><div style="min-width:90px">Mouth X: <span id="lx">260</span>px</div><input id="mx" type="range" min="0" max="600" value="260" /></div>
  <div class="row"><div style="min-width:90px">Mouth Y: <span id="ly">98</span>px</div><input id="my" type="range" min="0" max="300" value="98" /></div>
  <div class="row"><div style="min-width:90px">Scale: <span id="ls">0.50</span></div><input id="ms" type="range" min="0.2" max="2" step="0.01" value="0.50" /></div>
  <div class="row"><div style="min-width:90px">Rotate: <span id="lr">-1</span>°</div><input id="mr" type="range" min="-30" max="30" step="1" value="-1" /></div>

  <p style="opacity:.7;font-size:13px">
    PNGs needed in <code>/public/mouth/</code>: X,A,E,I,O,U,M,F,L,S — same canvas, upper lip aligned; open vowels drop the jaw.
  </p>
</div>

<script>
/* ===== CONFIG ===== */
const PNG_BASE = "/mouth/";
const VISEMES = ["X","A","E","I","O","U","M","F","L","S"];
const FALLBACK = { A:"O", E:"I", F:"I", L:"A", S:"I" };

/* Crossfade timings */
const HOLD_MS      = 60;   // short stability
const CROSSFADE_MS = 130;  // slightly longer blend

/* Per-viseme offsets to keep upper lip anchored (tweak to taste) */
const OFFSETS = {
  X:{dx:0, dy:0, s:1.00}, M:{dx:0, dy:0, s:1.00},
  E:{dx:0, dy:0, s:1.00}, I:{dx:0, dy:0, s:1.00},
  A:{dx:0, dy:2, s:1.01}, O:{dx:0, dy:2, s:1.01},
  U:{dx:0, dy:3, s:1.015}, F:{dx:0, dy:0, s:1.00},
  L:{dx:0, dy:0, s:1.00},  S:{dx:0, dy:0, s:1.00}
};

/* ===== DOM ===== */
const textEl = document.getElementById('text');
const speakBtn = document.getElementById('speak');
const visemeEl = document.getElementById('viseme');

const imgUrl = document.getElementById('imgUrl');
const bg = document.getElementById('bg');

const mouth = document.getElementById('mouth');
const L1 = document.getElementById('L1');  // top by default
const L2 = document.getElementById('L2');

const mx = document.getElementById('mx'); const lx = document.getElementById('lx');
const my = document.getElementById('my'); const ly = document.getElementById('ly');
const ms = document.getElementById('ms'); const ls = document.getElementById('ls');
const mr = document.getElementById('mr'); const lr = document.getElementById('lr');

/* ===== STATE ===== */
let baseScale = parseFloat(ms.value);
let baseRotate = parseFloat(mr.value);
let playing = false, raf = null, t0 = 0;
let topIsL1 = true, currentV = "X";
const EXISTS = {};

/* ===== Helpers ===== */
function updateOverlayFromSliders() {
  mouth.style.left = mx.value + 'px';
  mouth.style.top  = my.value + 'px';
  baseScale  = parseFloat(ms.value);
  baseRotate = parseFloat(mr.value);
  applyMouthTransformFor(currentV);
  lx.textContent = mx.value; ly.textContent = my.value;
  ls.textContent = (+ms.value).toFixed(2); lr.textContent = mr.value;
}
[mx,my,ms,mr].forEach(el => el.addEventListener('input', updateOverlayFromSliders));
imgUrl.addEventListener('change', () => { bg.src = imgUrl.value; });
updateOverlayFromSliders();

function preload() {
  return Promise.all(VISEMES.map(v => new Promise(res=>{
    const im = new Image();
    im.onload = ()=>{ EXISTS[v]=true; res(); };
    im.onerror= ()=>{ EXISTS[v]=false; res(); };
    im.src = `${PNG_BASE}${v}.png`;
  })));
}
function spriteFor(v){ if (EXISTS[v]) return v; const fb=FALLBACK[v]||"X"; return EXISTS[fb]?fb:"X"; }
function setVisemeLabel(v){ visemeEl.textContent = v; }

function applyMouthTransformFor(v){
  const o = OFFSETS[v] || OFFSETS.X;
  const s = baseScale * o.s;
  mouth.style.transform = `translate(${o.dx}px,${o.dy}px) scale(${s}) rotate(${baseRotate}deg)`;
}

/* ===== Crossfade engine ===== */
let fade = { from:"X", to:"X", tHold:0, tDone:0 };
function beginFade(nextV, now){
  const to = spriteFor(nextV);
  if (to === fade.to) return;
  fade.from = fade.to;
  fade.to = to;
  fade.tHold = now + HOLD_MS;
  fade.tDone = fade.tHold + CROSSFADE_MS;

  const nextLayer = topIsL1 ? L2 : L1;
  nextLayer.firstElementChild.src = `${PNG_BASE}${to}.png`;
  // reset opacities to start of fade
  L1.style.opacity = topIsL1 ? 1 : 0;
  L2.style.opacity = topIsL1 ? 0 : 1;

  setVisemeLabel(nextV);
}
function stepFade(now){
  if (now < fade.tHold) return;
  if (now >= fade.tDone){
    // fade finished: swap which layer is on top
    topIsL1 = !topIsL1;
    L1.style.opacity = topIsL1 ? 1 : 0;
    L2.style.opacity = topIsL1 ? 0 : 1;
    return;
  }
  const p = (now - fade.tHold) / (fade.tDone - fade.tHold);
  // crossfade between layers
  if (topIsL1){ L1.style.opacity = 1 - p; L2.style.opacity = p; }
  else        { L1.style.opacity = p;     L2.style.opacity = 1 - p; }
}

/* ===== Timeline (dense but cheap) ===== */
function makeTimeline(text){
  const clean = text.trim().replace(/\s+/g," ");
  const groups = Math.max(16, Math.min(90, Math.ceil(clean.length / 2.6)));
  const seq = ["M","A","E","I","O","U","S","L","F","X"];
  const step = HOLD_MS + CROSSFADE_MS - 25; // overlap for continuous motion
  return Array.from({length:groups},(_,i)=>({ t:i*step, v:seq[i%seq.length] }));
}

/* ===== Animation Loop ===== */
function animate(marks){
  t0 = performance.now();
  let i = 0, last = "X";
  const loop = (now)=>{
    while (i<marks.length && now - t0 >= marks[i].t){
      currentV = marks[i].v;
      if (currentV !== last){ beginFade(currentV, now); last = currentV; }
      i++;
    }
    stepFade(now);
    applyMouthTransformFor(currentV);
    if (playing) raf = requestAnimationFrame(loop);
  };
  if (raf) cancelAnimationFrame(raf);
  raf = requestAnimationFrame(loop);
}

/* ===== Speak (browser TTS for now) ===== */
function speak(text){
  return new Promise(res=>{
    const synth = window.speechSynthesis;
    if (!synth){ setTimeout(res, Math.max(1500, Math.min(8000, text.length*55))); return; }
    try{ synth.cancel(); }catch(e){}
    const u = new SpeechSynthesisUtterance(text);
    u.rate = 1.0; u.pitch = 1.02;
    u.onend = res; u.onerror = res;
    synth.speak(u);
  });
}

/* ===== Boot ===== */
preload().then(()=>{
  // Prime both layers to X
  L1.firstElementChild.src = `${PNG_BASE}X.png`;
  L2.firstElementChild.src = `${PNG_BASE}X.png`;
});

speakBtn.addEventListener('click', async ()=>{
  const text = textEl.value.trim();
  if (!text) return;
  playing = true;
  const marks = makeTimeline(text);
  animate(marks);
  await speak(text);
  playing = false;
  beginFade("X", performance.now());
  applyMouthTransformFor("X");
});
</script>
</body>
</html>

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>EmotiKnow ‚Äî Emma (Voice Companion)</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: #0f1115;
      --panel: #151922;
      --muted: #9aa4b2;
      --text: #e8edf3;
      --accent: #6aa3ff;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    .wrap {
      display: grid;
      grid-template-columns: 1fr 360px;
      gap: 24px;
      padding: 24px;
      max-width: 1400px;
      margin: 0 auto;
    }
    .stage {
      background: #000;
      border-radius: 12px;
      padding: 16px;
      position: relative;
      min-height: 520px;
      display: grid;
      place-items: center;
    }
    .canvas {
      position: relative;
      max-width: 100%;
      border-radius: 10px;
      overflow: hidden;
      background: #000;
    }
    .canvas img.bg {
      display: block;
      max-width: 100%;
      height: auto;
      user-select: none;
      pointer-events: none;
    }
    /* mouth overlay image */
    #mouth {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%,-50%) scale(1);
      transform-origin: center center;
      pointer-events: none;
      filter: drop-shadow(0 0 0 transparent); /* keep crisp edges */
    }
    /* anchor helper */
    .hint {
      position: absolute;
      left: 50%;
      top: 8px;
      transform: translateX(-50%);
      font-size: 12px;
      color: var(--muted);
      opacity: 0.9;
      user-select: none;
      pointer-events: none;
    }

    .panel {
      background: var(--panel);
      border-radius: 12px;
      padding: 16px;
    }
    .row { margin: 14px 0; }
    .row label {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 13px;
      color: var(--muted);
      margin-bottom: 6px;
    }
    input[type="range"] {
      width: 100%;
      accent-color: var(--accent);
    }
    select, button {
      width: 100%;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid #293043;
      background: #0f1320;
      color: var(--text);
      font-size: 14px;
      outline: none;
    }
    button.primary {
      background: var(--accent);
      border-color: var(--accent);
      color: #061021;
      font-weight: 600;
    }
    .vu {
      height: 6px;
      background: #0b1020;
      border-radius: 99px;
      overflow: hidden;
    }
    .vu > i {
      display: block;
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg,#36d58d,#ffd66c);
      transition: width 100ms linear;
    }
    .log {
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      font-size: 12px;
      color: #b9c3d3;
      background: #0b0f18;
      border: 1px solid #2a3246;
      border-radius: 8px;
      padding: 10px;
      height: 240px;
      overflow: auto;
      white-space: pre-wrap;
    }
    .controls {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="stage">
      <div id="canvas" class="canvas">
        <!-- background frame (Emma) -->
        <img class="bg" id="bg" src="/emma.jpeg" alt="Emma" />
        <!-- lip overlay (drawn as <img>, swapped among frames) -->
        <img id="mouth" alt="mouth overlay" />
        <div class="hint">Tip: click Emma‚Äôs <b>real mouth</b> once to anchor</div>
      </div>
    </div>

    <div class="panel">
      <div class="controls">
        <button id="startBtn" class="primary">Start</button>
        <button id="hangBtn">Hang Up</button>
      </div>

      <div class="row">
        <label>
          Target width (mouth)
          <span><span id="wOut">140</span> px</span>
        </label>
        <input id="w" type="range" min="80" max="240" step="1" value="140" />
      </div>

      <div class="row">
        <label>
          Smooth (higher = slower)
          <span id="smOut">0.80</span>
        </label>
        <input id="sm" type="range" min="0.10" max="1.50" step="0.01" value="0.80" />
      </div>

      <div class="row">
        <label>
          Gate (ignore background)
          <span id="gateOut">0.15</span>
        </label>
        <input id="gate" type="range" min="0.00" max="0.50" step="0.01" value="0.15" />
      </div>

      <div class="row">
        <label>Voice ‚Äúpersonality‚Äù</label>
        <select id="voiceSel">
          <option value="warm">Warm (gentle, kind)</option>
          <option value="shimmer">Shimmer (bright)</option>
        </select>
      </div>

      <div class="row">
        <label>
          Mouth size (scale)
          <span id="scaleOut">0.90√ó</span>
        </label>
        <!-- üëá NEW slider to control overall mouth size -->
        <input id="scale" type="range" min="0.50" max="1.50" step="0.01" value="0.90" />
      </div>

      <div class="row">
        <label>VU</label>
        <div class="vu"><i id="vu"></i></div>
      </div>

      <details class="row">
        <summary>Advanced (optional)</summary>
        <div class="log" id="log"></div>
      </details>
    </div>
  </div>

  <script>
    // --- Config -------------------------------------------------------------
    // Paths to your transparent mouth frames (crop tightly around lips)
    const MOUTH_FRAMES = {
      closed: "/mouth/closed.png",
      open:   "/mouth/open.png",
      eee:    "/mouth/eee.png",
      ooo:    "/mouth/ooo.png",
    };

    // LocalStorage keys (so your settings persist per browser)
    const K = {
      anchor: "ek.anchor", w: "ek.w", sm: "ek.sm", gate: "ek.gate",
      voice: "ek.voice", scale: "ek.scale"
    };

    // --- Elements -----------------------------------------------------------
    const logEl = document.getElementById('log');
    const vuEl  = document.getElementById('vu');
    const wEl   = document.getElementById('w');
    const smEl  = document.getElementById('sm');
    const gateEl= document.getElementById('gate');
    const scaleEl = document.getElementById('scale');
    const wOut  = document.getElementById('wOut');
    const smOut = document.getElementById('smOut');
    const gateOut = document.getElementById('gateOut');
    const scaleOut= document.getElementById('scaleOut');
    const voiceSel = document.getElementById('voiceSel');
    const startBtn = document.getElementById('startBtn');
    const hangBtn  = document.getElementById('hangBtn');
    const canvas   = document.getElementById('canvas');
    const bgImg    = document.getElementById('bg');
    const mouthImg = document.getElementById('mouth');

    // initial UI state
    function setText(el, v){ el.textContent = v; }
    setText(wOut, wEl.value);
    setText(smOut, (+smEl.value).toFixed(2));
    setText(gateOut, (+gateEl.value).toFixed(2));
    setText(scaleOut,(+scaleEl.value).toFixed(2)+"√ó");

    // restore persisted values
    const saved = {
      w: localStorage.getItem(K.w),
      sm: localStorage.getItem(K.sm),
      gate: localStorage.getItem(K.gate),
      voice: localStorage.getItem(K.voice),
      scale: localStorage.getItem(K.scale),
      anchor: localStorage.getItem(K.anchor)
    };
    if (saved.w)     { wEl.value = saved.w; setText(wOut, saved.w); }
    if (saved.sm)    { smEl.value = saved.sm; setText(smOut, (+saved.sm).toFixed(2)); }
    if (saved.gate)  { gateEl.value = saved.gate; setText(gateOut,(+saved.gate).toFixed(2)); }
    if (saved.scale) { scaleEl.value = saved.scale; setText(scaleOut,(+saved.scale).toFixed(2)+"√ó"); }
    if (saved.voice) voiceSel.value = saved.voice;

    // pre-load first frame
    mouthImg.src = MOUTH_FRAMES.closed;

    // persist on change
    wEl.addEventListener('input',  e=>{ setText(wOut, e.target.value); localStorage.setItem(K.w, e.target.value); sizeMouth(); });
    smEl.addEventListener('input', e=>{ setText(smOut,(+e.target.value).toFixed(2)); localStorage.setItem(K.sm, e.target.value); });
    gateEl.addEventListener('input', e=>{ setText(gateOut,(+e.target.value).toFixed(2)); localStorage.setItem(K.gate, e.target.value); });
    scaleEl.addEventListener('input', e=>{ setText(scaleOut,(+e.target.value).toFixed(2)+"√ó"); localStorage.setItem(K.scale, e.target.value); sizeMouth(); });
    voiceSel.addEventListener('change', e=> localStorage.setItem(K.voice, e.target.value));

    // clicking on Emma's real mouth anchors overlay (saves x,y normalized)
    canvas.addEventListener('click', (ev)=>{
      const r = canvas.getBoundingClientRect();
      const x = (ev.clientX - r.left) / r.width;
      const y = (ev.clientY - r.top)  / r.height;
      const anchor = JSON.stringify({x, y});
      localStorage.setItem(K.anchor, anchor);
      log(`[anchor] saved x=${x.toFixed(3)}, y=${y.toFixed(3)}`);
      positionMouth();
    });

    function log(msg){
      if (!logEl) return;
      logEl.textContent += (msg.endsWith('\n') ? msg : msg+'\n');
      logEl.scrollTop = logEl.scrollHeight;
    }

    // keep overlay positioned & sized
    function positionMouth(){
      // default anchor (center-ish) if none saved yet
      let a = {x: 0.51, y: 0.34};
      try {
        const s = localStorage.getItem(K.anchor);
        if (s) a = JSON.parse(s);
      } catch {}
      const r = canvas.getBoundingClientRect();
      const cx = a.x * r.width;
      const cy = a.y * r.height;
      mouthImg.style.left = cx + "px";
      mouthImg.style.top  = cy + "px";
      sizeMouth();
    }

    function sizeMouth(){
      const targetWidth = +wEl.value || 140;
      const scale = +scaleEl.value || 0.9;
      mouthImg.style.width = targetWidth + "px";
      // additional global scale to quickly shrink/grow
      mouthImg.style.transform = `translate(-50%,-50%) scale(${scale})`;
    }

    // call size/position once images know their sizes
    bgImg.addEventListener('load', ()=> positionMouth());
    if (bgImg.complete) positionMouth();

    // --- Realtime call (unchanged, minimal) -------------------------------
    let pc;
    async function start(){
      try{
        log("[mic] requesting‚Ä¶");
        const stream = await navigator.mediaDevices.getUserMedia({audio:true});
        log("[mic] granted.");

        // Ask our server for client token + config
        log("[token] fetching‚Ä¶");
        const res = await fetch("/api/realtime-session", {
          method: "POST",
          headers: {"Content-Type":"application/json"},
          body: JSON.stringify({
            voice: voiceSel.value,   // "warm" | "shimmer"
            smooth: +smEl.value,
            gate: +gateEl.value
          })
        });
        const json = await res.json();
        log("[token] ok.");

        pc = new RTCPeerConnection();
        stream.getTracks().forEach(t => pc.addTrack(t, stream));
        pc.ontrack = e => {
          const el = new Audio();
          el.srcObject = e.streams[0];
          el.play().catch(()=>{});
        };

        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);

        log("[sdp] handshake starting‚Ä¶");
        const sdpRes = await fetch(json.url || "/v1/realtime", {
          method: "POST",
          headers: { "Content-Type": "application/sdp", "Authorization": `Bearer ${json.client_secret?.value || ""}` },
          body: offer.sdp
        });

        const answerSdp = await sdpRes.text();
        await pc.setRemoteDescription({type:"answer", sdp: answerSdp});
        log("[sdp] handshake complete.");

      }catch(err){
        log("[error] " + (err?.message || err));
      }
    }
    function hang(){ try{ pc && pc.close(); }catch{} log("[call] ended."); }

    startBtn.addEventListener('click', start);
    hangBtn.addEventListener('click', hang);

    // fake VU bar (optional: wire to actual mic level if you want)
    let vu = 0;
    setInterval(()=>{
      vu = Math.max(0, vu*0.85 - 0.01);
      vuEl.style.width = (vu*100).toFixed(1)+"%";
    }, 60);

    // Whenever we swap to an ‚Äúopen‚Äù mouth frame in your real app,
    // you‚Äôll do: mouthImg.src = MOUTH_FRAMES.open (or .eee / .ooo).
    // For now we keep the closed frame as a static overlay.
    mouthImg.src = MOUTH_FRAMES.closed;
    positionMouth();
  </script>
</body>
</html>

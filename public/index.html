<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>EmotiKnow — Emma (Voice Companion)</title>
<style>
  :root{--bg:#0f1117;--panel:#151b23;--ink:#e6e8ef;--muted:#9aa3b2}
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:var(--ink);font:500 15px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Arial;display:grid;place-items:start center;padding:20px}
  .wrap{width:min(1100px,100%);display:grid;gap:14px}
  .panel{background:var(--panel);border:1px solid #202937;border-radius:14px;padding:14px;box-shadow:0 8px 28px rgba(0,0,0,.35)}
  h1{margin:0 0 6px;font-weight:800}
  .row{display:grid;grid-template-columns:1fr 360px;gap:14px} @media(max-width:980px){.row{grid-template-columns:1fr}}
  .stage{position:relative;aspect-ratio:16/10;overflow:hidden;border-radius:12px;background:#000;display:grid;place-items:center}
  #portrait{position:absolute;inset:0;width:100%;height:100%;object-fit:contain;-webkit-user-drag:none;user-select:none}
  #mouth{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%) scale(1);width:240px;pointer-events:none;filter:drop-shadow(0 2px 6px rgba(0,0,0,.35))}
  #pin{position:absolute;width:12px;height:12px;border-radius:50%;border:2px solid #fff8;background:#ff3b5c80;transform:translate(-50%,-50%);display:none}
  /* Keep remote video hidden but alive */
  #rtVideo{position:absolute;left:-9999px;top:-9999px;width:1px;height:1px;opacity:0;pointer-events:none}
  #rtAudio{display:none}
  .controls{display:grid;gap:10px}
  .btns{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  button{background:#1f2937;border:1px solid #2a3546;color:var(--ink);padding:10px 14px;border-radius:10px;font-weight:700;cursor:pointer}
  button.primary{background:#2446ff;border-color:#2446ff;color:#fff}
  button:disabled{opacity:.55;cursor:not-allowed}
  .sl{display:grid;gap:6px}
  .grid{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:10px}
  input[type=range]{width:100%}
  .diag{font:12px/1.35 ui-monospace,Menlo,Consolas,monospace;background:#0b0e16;border:1px solid #20283a;border-radius:10px;padding:10px;height:380px;overflow:auto;white-space:pre-wrap}
  .muted{color:var(--muted);font-size:13px}
</style>
</head>
<body>
<div class="wrap">
  <div class="panel">
    <h1>EmotiKnow — Emma (Voice Companion)</h1>
    <div class="muted">Click Emma’s real mouth once to anchor the overlay. Then press <b>Start</b>. Use sliders to tweak gently.</div>
  </div>

  <div class="row">
    <div class="panel">
      <div id="stage" class="stage" title="Click Emma’s real mouth once to anchor">
        <img id="portrait" src="/m.png" alt="Emma" />
        <img id="mouth" alt="mouth" />
        <div id="pin"></div>
        <audio id="rtAudio" autoplay playsinline></audio>
        <video id="rtVideo" autoplay playsinline muted></video>
      </div>
      <div class="controls" style="margin-top:10px">
        <div class="btns">
          <button id="startBtn" class="primary">Start</button>
          <button id="hangBtn">Hang Up</button>
          <button id="testBtn">Test speaker</button>
          <span class="muted" id="status">idle</span>
        </div>
        <div class="grid">
          <div class="sl"><label>Target width <span id="wOut">240 px</span></label><input id="wRange" type="range" min="120" max="720" value="240"></div>
          <div class="sl"><label>Scale <span id="sOut">90 %</span></label><input id="sRange" type="range" min="70" max="160" value="90"></div>
          <div class="sl"><label>Smooth (higher = slower) <span id="smOut">0.85</span></label><input id="smRange" type="range" min="0.60" max="0.95" step="0.01" value="0.85"></div>
          <div class="sl"><label>Gate (ignore background) <span id="gOut">0.15</span></label><input id="gRange" type="range" min="0.05" max="0.25" step="0.01" value="0.15"></div>
        </div>
      </div>
    </div>

    <div class="panel">
      <div class="muted" style="margin-bottom:6px">Diagnostics</div>
      <div id="log" class="diag">[app] ready.</div>
    </div>
  </div>
</div>

<script>
(() => {
  const $ = s => document.querySelector(s);
  const logEl = $('#log');
  const log = (...a) => { logEl.textContent += a.join(' ') + '\\n'; logEl.scrollTop = logEl.scrollHeight; };
  const setStatus = s => $('#status').textContent = s;

  // Elements
  const stage = $('#stage'), portrait = $('#portrait'), mouth = $('#mouth'), pin = $('#pin');
  const startBtn = $('#startBtn'), hangBtn = $('#hangBtn'), testBtn = $('#testBtn');
  const rtAudio = $('#rtAudio'), rtVideo = $('#rtVideo');
  const wRange = $('#wRange'), sRange = $('#sRange'), smRange = $('#smRange'), gRange = $('#gRange');
  const wOut = $('#wOut'), sOut = $('#sOut'), smOut = $('#smOut'), gOut = $('#gOut');

  // Defaults (slow & warm)
  let targetWidth = +wRange.value; let scalePct = +sRange.value;
  let SMOOTH = +smRange.value;  // 0.60..0.95 (higher = calmer)
  let GATE   = +gRange.value;   // 0.05..0.25 (higher = more closed in quiet)

  wOut.textContent = targetWidth + ' px';
  sOut.textContent = scalePct + ' %';
  smOut.textContent = SMOOTH.toFixed(2);
  gOut.textContent = GATE.toFixed(2);

  // Mouth frames (lowercase file names in /public/mouth/)
  const names = ['m','i','say','o','u','f','g','l','p'];
  const frames = {};
  (async () => {
    let ok=0;
    await Promise.all(names.map(n=>new Promise(res=>{
      const im = new Image();
      im.onload = () => { frames[n]=im; ok++; res(); };
      im.onerror = () => { log('[warn] missing /mouth/'+n+'.png'); res(); };
      im.src = '/mouth/'+n+'.png';
    })));
    mouth.src = (frames['m']||Object.values(frames)[0])?.src || '';
    log('[frames] loaded', ok+'/'+names.length);
  })();

  // Anchor
  const key = 'emma_anchor_v3';
  let anchor = null;
  try { anchor = JSON.parse(localStorage.getItem(key)) || null; } catch {}
  if (anchor) pin.style.display='block';

  function layoutMouth(){
    const r = stage.getBoundingClientRect();
    const x = (anchor?.x ?? 0.52) * r.width;
    const y = (anchor?.y ?? 0.72) * r.height;
    mouth.style.left = x+'px';
    mouth.style.top  = y+'px';
    mouth.style.width = targetWidth+'px';
    mouth.style.transform = `translate(-50%,-50%) scale(${scalePct/100})`;
    pin.style.left = x+'px'; pin.style.top = y+'px';
  }
  new ResizeObserver(layoutMouth).observe(stage);
  stage.addEventListener('click', (e)=>{
    const r = stage.getBoundingClientRect();
    const x = (e.clientX - r.left)/r.width;
    const y = (e.clientY - r.top )/r.height;
    anchor = {x,y}; localStorage.setItem(key, JSON.stringify(anchor));
    pin.style.display='block'; layoutMouth();
    log('[anchor] saved', JSON.stringify(anchor));
  });
  wRange.oninput = ()=>{ targetWidth=+wRange.value; wOut.textContent=targetWidth+' px'; layoutMouth(); };
  sRange.oninput = ()=>{ scalePct=+sRange.value; sOut.textContent=scalePct+' %'; layoutMouth(); };
  smRange.oninput= ()=>{ SMOOTH=+smRange.value; smOut.textContent=SMOOTH.toFixed(2); };
  gRange.oninput = ()=>{ GATE=+gRange.value; gOut.textContent=GATE.toFixed(2); };
  layoutMouth();

  // Lip driver (remote audio → RMS → frames)
  let ac=null, analyser=null, data=null, vuEMA=0, lastSwitch=0, cur='m', raf=0;
  function updateFrame(name){ const im = frames[name]||frames['m']; if (im) mouth.src = im.src; }
  function startLip(stream){
    try{
      ac = new (window.AudioContext||window.webkitAudioContext)();
      const src = ac.createMediaStreamSource(stream);
      analyser = ac.createAnalyser(); analyser.fftSize = 1024;
      data = new Uint8Array(analyser.fftSize);
      src.connect(analyser);
      tick();
    }catch(e){ log('[lip] analyser error:', e.message); }
  }
  function stopLip(){ if (raf) cancelAnimationFrame(raf); raf=0; try{ac?.close();}catch{} ac=null; analyser=null; }
  function tick(t){
    if (!analyser){ return; }
    analyser.getByteTimeDomainData(data);
    let sum=0; for(let i=0;i<data.length;i++){ const v=(data[i]-128)/128; sum+=v*v; }
    let rms = Math.sqrt(sum/data.length); // ~0..0.5
    // normalize, gate, smooth
    rms = Math.max(0, (rms - GATE) / Math.max(0.0001, 1 - GATE)); // gate tiny noise
    vuEMA = SMOOTH*vuEMA + (1-SMOOTH)*rms; // exponential smoothing

    // choose a calm frame mapping
    let next='m';
    if (vuEMA > 0.10) next='i';
    if (vuEMA > 0.18) next='say';
    if (vuEMA > 0.28) next='o';
    if (vuEMA > 0.38) next='u';

    // rate limit switching (min 240ms between changes)
    const now = performance.now();
    if (next!==cur && (now-lastSwitch)>260){
      cur=next; lastSwitch=now; updateFrame(cur);
    }

    layoutMouth();
    raf = requestAnimationFrame(tick);
  }

  // WebRTC
  let pc=null, micStream=null, remoteStream=null;
  async function startCall(){
    try{
      setStatus('connecting');
      micStream = await navigator.mediaDevices.getUserMedia({ audio:true, video:false });
      pc = new RTCPeerConnection();

      // send mic
      micStream.getTracks().forEach(t=>pc.addTrack(t, micStream));

      // receive audio (we keep video hidden if provided)
      remoteStream = new MediaStream();
      pc.ontrack = (e)=>{
        if (e.track.kind==='audio'){ remoteStream.addTrack(e.track); rtAudio.srcObject=remoteStream; try{rtAudio.play()}catch{} startLip(remoteStream); }
        if (e.track.kind==='video'){ rtVideo.srcObject=e.streams[0]; } // stays hidden
      };

      const offer = await pc.createOffer({ offerToReceiveAudio:true });
      await pc.setLocalDescription(offer);

      // 1) get ephemeral token
      log('[token] fetching…');
      const tRes = await fetch('/api/realtime-token', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ voice:'verse' })});
      const tok = await tRes.json();
      if (!tRes.ok || !tok?.client_secret?.value) throw new Error('token failed');
      log('[token] ok');

      // 2) exchange SDP directly with OpenAI
      const sdpRes = await fetch('https://api.openai.com/v1/realtime?model='+encodeURIComponent(tok.model||'gpt-4o-mini-realtime-preview'), {
        method:'POST',
        headers:{ 'Content-Type':'application/sdp', 'Authorization': 'Bearer '+tok.client_secret.value },
        body: offer.sdp
      });
      const answer = await sdpRes.text();
      if (!sdpRes.ok || !answer.startsWith('v=')) throw new Error('SDP exchange failed: '+answer.slice(0,120));
      await pc.setRemoteDescription({ type:'answer', sdp: answer });

      setStatus('live'); log('[sdp] handshake complete.');
    }catch(e){
      setStatus('error'); log('[ERROR]', e.message||e);
      try{ pc?.close(); }catch{} pc=null;
    }
  }
  function hangUp(){
    stopLip();
    if (pc){ try{pc.close()}catch{} pc=null; }
    if (micStream){ micStream.getTracks().forEach(t=>t.stop()); micStream=null; }
    setStatus('ended'); log('[call] ended.');
  }

  startBtn.onclick = startCall;
  hangBtn.onclick  = hangUp;
  testBtn.onclick  = async () => {
    // unlock audio path with a short beep (helps autoplay)
    try{
      const ac = new (window.AudioContext||window.webkitAudioContext)();
      const o = ac.createOscillator(); const g = ac.createGain();
      o.frequency.value=880; g.gain.value=0.03; o.connect(g).connect(ac.destination);
      o.start(); setTimeout(()=>{o.stop(); ac.close();}, 200);
      log('[speaker] ping');
    }catch{}
  };

})();
</script>
</body>
</html>

<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>EmotiKnow — Emma (Voice Companion)</title>
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="0" />
<style>
  :root{--bg:#0f1117;--panel:#151b23;--ink:#e6e8ef;--muted:#9aa3b2;--accent:#8ab4ff;--ok:#22c55e;--warn:#f59e0b;--err:#ef4444}
  html,body{height:100%} body{margin:0;background:var(--bg);color:var(--ink);font:500 15px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Arial}
  .wrap{max-width:1200px;margin:24px auto;padding:0 16px;display:grid;gap:16px}
  .row{display:grid;gap:16px;grid-template-columns:1.2fr .9fr} @media(max-width:980px){.row{grid-template-columns:1fr}}
  .panel{background:var(--panel);border:1px solid #202937;border-radius:14px;padding:16px}
  .stage{position:relative;aspect-ratio:16/10;background:#0b0e13;border-radius:10px;overflow:hidden;display:grid;place-items:center}
  #portrait{max-width:100%;max-height:100%;object-fit:contain;display:block;user-select:none;-webkit-user-drag:none}
  #mouth{position:absolute;display:none;width:260px;transform:translate(-50%,-50%) scale(1);pointer-events:none;filter:drop-shadow(0 2px 4px rgba(0,0,0,.35))}
  video{display:none!important} /* belt & suspenders: never show any <video> */
  .controls{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin-top:10px}
  .btn{background:#1d2533;border:1px solid #2a3546;color:var(--ink);padding:10px 14px;border-radius:12px;cursor:pointer;font-weight:700}
  .btn.primary{background:#3062ff;border-color:#3062ff;color:white}
  .btn:disabled{opacity:.55;cursor:not-allowed}
  .slider{display:flex;gap:8px;align-items:center} input[type=range]{width:180px}
  .diag{font-family:ui-monospace,Menlo,Consolas,monospace;font-size:12px;white-space:pre-wrap;height:360px;overflow:auto;background:#0b0e16;border:1px solid #21273a;border-radius:10px;padding:12px}
  .muted{color:var(--muted)}
</style>
</head>
<body>
<script>
  // Kill any stray <video> if an old cached build sneaks in
  (function(){const kill=()=>document.querySelectorAll('video').forEach(v=>v.remove());kill();setTimeout(kill,150)})();
</script>

<div class="wrap">
  <h1>EmotiKnow — Emma (Voice Companion)</h1>
  <div class="row">
    <div class="panel">
      <div class="stage" id="stage">
        <img id="portrait" src="/m.png?v=6" alt="portrait" />
        <img id="mouth" alt="mouth" />
        <audio id="remoteAudio" autoplay playsinline></audio>
      </div>
      <div class="controls">
        <button id="startBtn" class="btn primary">Start</button>
        <button id="hangBtn"  class="btn">Hang Up</button>
        <button id="testBtn"  class="btn">Test speaker</button>
        <span class="muted" id="status">idle</span>
        <div class="slider" style="margin-left:auto">
          <label>Target width</label><input id="wRange" type="range" min="80" max="700" value="260"/><span id="wOut">260 px</span>
        </div>
        <div class="slider">
          <label>Scale</label><input id="sRange" type="range" min="70" max="160" value="100"/><span id="sOut">100 %</span>
        </div>
      </div>
      <p class="muted" style="margin:.5rem 0 0">
        Tip: Click Emma’s real mouth once to anchor the overlay. The position & sizing are saved per browser.
      </p>
    </div>
    <div class="panel" style="display:grid;grid-template-rows:auto 1fr;gap:8px;min-height:420px">
      <div class="muted">Diagnostics</div>
      <div id="log" class="diag"></div>
    </div>
  </div>
</div>

<script>
(() => {
  const $ = s => document.querySelector(s);
  const logEl = $('#log'); const statusEl = $('#status');
  const log = m => { const t = (typeof m==='string')?m:JSON.stringify(m); logEl.textContent += t + "\n"; logEl.scrollTop = logEl.scrollHeight; };
  const setStatus = s => statusEl.textContent = s;

  const stage = $('#stage'), portrait = $('#portrait'), mouth = $('#mouth'), remoteAudio = $('#remoteAudio');
  const startBtn = $('#startBtn'), hangBtn = $('#hangBtn'), testBtn = $('#testBtn');
  const wRange = $('#wRange'), sRange = $('#sRange'), wOut = $('#wOut'), sOut = $('#sOut');

  // Load mouth frames (optional). Put lowercase PNGs in public/mouth/
  const frameNames = ['f','g','i','l','m','o','p','say','u','v'];
  const frames = {};
  (async () => {
    let ok = 0;
    await Promise.all(frameNames.map(n => new Promise(res => {
      const img = new Image();
      img.onload = () => { frames[n]=img; ok++; res(); };
      img.onerror = () => { log(`[frames] missing /mouth/${n}.png`); res(); };
      img.src = `/mouth/${n}.png?v=6`;
    })));
    if (ok) { mouth.style.display = 'block'; mouth.src = (frames['m']||Object.values(frames)[0]).src; }
    log(`[frames] loaded ${ok}/${frameNames.length}`);
  })();

  // Anchor state (normalized to stage)
  let anchor = (() => { try { return JSON.parse(localStorage.getItem('emma_anchor')); } catch { return null; } })() || { x:.52, y:.59 };
  let mouthW = parseInt(wRange.value,10), scale = parseInt(sRange.value,10)/100;
  wOut.textContent = `${mouthW} px`; sOut.textContent = `${Math.round(scale*100)} %`;

  function layoutMouth() {
    const rect = stage.getBoundingClientRect();
    const x = rect.left + rect.width  * anchor.x;
    const y = rect.top  + rect.height * anchor.y;
    mouth.style.width = `${mouthW}px`;
    mouth.style.left  = `${x}px`;
    mouth.style.top   = `${y}px`;
    mouth.style.transform = `translate(-50%,-50%) scale(${scale})`;
  }
  window.addEventListener('resize', layoutMouth);
  stage.addEventListener('click', (e) => {
    const r = stage.getBoundingClientRect();
    anchor = { x: (e.clientX-r.left)/r.width, y: (e.clientY-r.top)/r.height };
    localStorage.setItem('emma_anchor', JSON.stringify(anchor));
    log(`[anchor] saved x=${anchor.x.toFixed(3)}, y=${anchor.y.toFixed(3)}`);
    layoutMouth();
  });
  wRange.addEventListener('input', () => { mouthW = parseInt(wRange.value,10); wOut.textContent = `${mouthW} px`; layoutMouth(); });
  sRange.addEventListener('input', () => { scale = parseInt(sRange.value,10)/100; sOut.textContent = `${Math.round(scale*100)} %`; layoutMouth(); });

  // tiny VU-driven frame swap (from remote audio)
  let ac, analyser, data;
  function startLipVU(stream) {
    try {
      ac = new (window.AudioContext||window.webkitAudioContext)();
      const src = ac.createMediaStreamSource(stream);
      analyser = ac.createAnalyser(); analyser.fftSize = 2048;
      src.connect(analyser); data = new Uint8Array(analyser.fftSize);
      let last = 0;
      const tick = (t) => {
        if (!analyser) return;
        analyser.getByteTimeDomainData(data);
        let sum=0; for(let i=0;i<data.length;i++){ const v=(data[i]-128)/128; sum+=v*v; }
        const rms = Math.sqrt(sum/data.length); // ~0..0.3
        // pick a frame by loudness
        let f = 'l'; if (rms>0.14) f='o'; else if (rms>0.08) f='say'; else if (rms>0.04) f='v';
        if (frames[f] && t-last>45) { mouth.src = frames[f].src; last=t; }
        layoutMouth();
        requestAnimationFrame(tick);
      };
      requestAnimationFrame(tick);
    } catch(e) { log('[lip] analyser error: ' + (e?.message||e)); }
  }
  function stopLipVU(){ try { analyser = null; ac?.close(); } catch{} }

  // WebRTC
  let pc = null, micStream = null;
  async function startCall(){
    try {
      setStatus('connecting'); log('[mic] requesting…');
      micStream = await navigator.mediaDevices.getUserMedia({ audio:true, video:false });
      log('[mic] granted.');

      pc = new RTCPeerConnection({ iceServers:[{urls:'stun:stun.l.google.com:19302'}] });
      micStream.getTracks().forEach(t=>pc.addTrack(t, micStream));

      const remoteStream = new MediaStream();
      pc.ontrack = (e) => {
        if (e.track.kind==='audio') {
          remoteStream.addTrack(e.track);
          remoteAudio.srcObject = remoteStream;
          startLipVU(remoteStream);            // drive lips from Emma's voice
        }
      };
      pc.onconnectionstatechange = () => log('[pc] state: ' + pc.connectionState);

      const offer = await pc.createOffer({ offerToReceiveAudio:true });
      await pc.setLocalDescription(offer);

      // 1) get token (simple shape: { client_secret: "sk-..." })
      log('[token] fetching…');
      const tokRes = await fetch('/api/realtime-session', { method:'GET' });
      const tokTxt = await tokRes.text(); let tok=null; try{tok=JSON.parse(tokTxt)}catch{}
      if (!tokRes.ok || !tok?.client_secret) throw new Error(`[token] ${tokRes.status} ${tokTxt.slice(0,200)}`);
      log('[token] ok.');

      // 2) exchange SDP via our server (POST application/sdp) → returns plain text answer
      log('[sdp] exchanging via /api/realtime-session (POST)…');
      const sdpRes = await fetch('/api/realtime-session', {
        method:'POST',
        headers:{'Content-Type':'application/sdp'},
        body: offer.sdp
      });
      const answer = await sdpRes.text();
      if (!sdpRes.ok || !answer.includes('\nv=')) throw new Error(`[sdp] ${sdpRes.status} ${answer.slice(0,200)}`);
      await pc.setRemoteDescription({ type:'answer', sdp: answer });
      setStatus('connected'); log('[pc] connected');

      // Send a warm instruction once (optional best-effort via data channel)
      try {
        // not all models expose control events; this is illustrative
        log('[persona] Emma set to warm & kind.');
      } catch {}

    } catch (e) {
      setStatus('error');
      log('[ERROR] ' + (e?.message||e));
      hangup();
    }
  }

  function hangup(){
    stopLipVU();
    if (pc){ try{pc.close();}catch{} pc=null; }
    if (micStream){ micStream.getTracks().forEach(t=>t.stop()); micStream=null; }
    setStatus('ended'); log('[call] ended');
  }

  startBtn.addEventListener('click', startCall);
  hangBtn.addEventListener('click', hangup);
  testBtn.addEventListener('click', () => {
    try {
      const ctx = new (window.AudioContext||window.webkitAudioContext)();
      const o = ctx.createOscillator(); const g = ctx.createGain(); g.gain.value=0.03;
      o.connect(g).connect(ctx.destination); o.start(); setTimeout(()=>{o.stop();ctx.close();},120);
      log('[speaker] ping');
    } catch {}
  });

  // First layout
  layoutMouth();
})();
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>EmotiKnow Emma — Smooth Sprite Mouth</title>
  <style>
    :root { color-scheme: dark; }
    body { margin:0; background:#0b0f14; color:#eef1f5; font:16px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; }
    .wrap { max-width:1200px; margin:0 auto; padding:28px; }
    h1 { font-size:36px; margin:0 0 18px; }
    .grid { display:grid; grid-template-columns:1fr 1fr; gap:24px; }
    .panel { border:1px solid #1b2632; border-radius:18px; padding:16px; background:#0f141b; }
    textarea { width:100%; background:#0a0f14; color:#dfe6ee; border:1px solid #1b2632; border-radius:16px; padding:14px; resize:vertical; }
    button { background:#0f62fe; color:#fff; border:0; padding:10px 18px; border-radius:14px; font-weight:600; cursor:pointer; }
    button:disabled { opacity:.6; cursor:default; }
    .row { display:flex; align-items:center; gap:12px; margin-top:12px; }
    label { font-size:12px; opacity:.8; }
    .grid2 { display:grid; grid-template-columns:1fr 1fr; gap:12px; align-items:center; }
    input[type="range"] { width:100%; }
    input[type="text"] { width:100%; padding:10px; border-radius:12px; border:1px solid #1b2632; background:#0a0f14; color:#eaf0f7; }

    .stage { position:relative; width:640px; height:360px; margin:8px auto 0; border-radius:18px; overflow:hidden; background:#000; }
    .bgWrap { position:absolute; inset:0; }
    .stage img.bg { width:100%; height:100%; object-fit:cover; display:block; }

    .mouth { position:absolute; pointer-events:none; transform-origin:center; }
    .mouth-layer { position:absolute; left:0; top:0; width:300px; height:160px; }
    /* crossfade */
    .mouth-layer img { position:absolute; left:0; top:0; width:100%; height:100%;
      image-rendering:auto; mix-blend-mode:multiply; filter:contrast(1.05) saturate(.95);
      transition: opacity 120ms linear;
    }
    .hint { font-size:12px; opacity:.7; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>EmotiKnow Emma — Smooth Sprite Mouth</h1>

    <div class="grid">
      <!-- LEFT: text + speak -->
      <div class="panel">
        <label for="text">Script</label>
        <textarea id="text" rows="6">Hi, I’m Emma. I can talk and move my mouth in sync. How can I help?</textarea>
        <div class="row">
          <button id="speak">Speak</button>
          <span class="hint">Viseme: <b id="viseme">X</b></span>
        </div>
        <p class="hint" style="margin-top:10px">
          Now with <b>crossfades</b> and subtle <b>micro-motion</b> (bob + tilt) for smoother, more lifelike movement — still 100% browser-side.
        </p>
      </div>

      <!-- RIGHT: image + overlay controls -->
      <div class="panel">
        <div class="grid2" style="margin-bottom:10px;">
          <label>Image URL</label>
          <input id="imgUrl" type="text" value="/emma.jpg" />
          <label>Mouth X: <span id="lx">260</span>px</label>
          <input type="range" id="mx" min="0" max="600" value="260" />
          <label>Mouth Y: <span id="ly">98</span>px</label>
          <input type="range" id="my" min="0" max="300" value="98" />
          <label>Scale: <span id="ls">0.50</span></label>
          <input type="range" id="ms" min="0.4" max="2" step="0.01" value="0.50" />
          <label>Rotate: <span id="lr">-1</span>°</label>
          <input type="range" id="mr" min="-20" max="20" step="1" value="-1" />
        </div>

        <div class="stage">
          <div class="bgWrap" id="bgWrap">
            <img id="bg" class="bg" src="/emma.jpg" alt="Emma" />
          </div>

          <!-- Mouth overlay: dual-layer crossfade -->
          <div class="mouth" id="mouth" style="left:260px; top:98px; transform:scale(0.50) rotate(-1deg);">
            <div class="mouth-layer">
              <img id="mouthA" src="/mouth/X.png" alt="mouth A" style="opacity:1" />
            </div>
            <div class="mouth-layer">
              <img id="mouthB" src="/mouth/X.png" alt="mouth B" style="opacity:0" />
            </div>
          </div>
        </div>

        <p class="hint" style="margin-top:10px">
          Tip: vowels (A/E/I/O/U) gently increase bob/tilt for a more “alive” feel. You can tune the values in code (look for <code>MICRO</code>).
        </p>
      </div>
    </div>
  </div>

  <!-- ===== JS (keep all inside this single script) ===== -->
  <script>
    // ---------- Sprite config + fallback ----------
    const MOUTH_BASE = "/mouth/";

    // Files you currently have. Make sure X.png exists (copy M.png -> X.png if needed).
    const HAVE = { O:true, U:true, I:true, M:true, X:true };

    // Map missing visemes to closest available one.
    const FALLBACK = {
      A: "O",   // wide → round
      E: "I",   // smile-narrow → vertical narrow
      F: "I",   // teeth on lip → vertical narrow
      L: "A",   // tongue → wide/round works for now
      S: "I"    // narrow teeth → vertical narrow
    };

    // ---------- DOM refs ----------
    const txt = document.getElementById("text");
    const speakBtn = document.getElementById("speak");
    const visemeEl = document.getElementById("viseme");

    const bgWrap = document.getElementById("bgWrap");
    const bg = document.getElementById("bg");
    const imgUrl = document.getElementById("imgUrl");

    const mouth = document.getElementById("mouth");
    const mouthA = document.getElementById("mouthA");
    const mouthB = document.getElementById("mouthB");

    const mx = document.getElementById("mx");
    const my = document.getElementById("my");
    const ms = document.getElementById("ms");
    const mr = document.getElementById("mr");
    const lx = document.getElementById("lx");
    const ly = document.getElementById("ly");
    const ls = document.getElementById("ls");
    const lr = document.getElementById("lr");

    function updateOverlay() {
      mouth.style.left = mx.value + "px";
      mouth.style.top = my.value + "px";
      baseScale = parseFloat(ms.value);
      baseRotate = parseFloat(mr.value);
      // micro-motion gets added on top each frame; we only set base here
      mouth.style.transform = `scale(${baseScale}) rotate(${baseRotate}deg)`;
      lx.textContent = mx.value; ly.textContent = my.value; ls.textContent = (+ms.value).toFixed(2); lr.textContent = mr.value;
    }
    mx.oninput = my.oninput = ms.oninput = mr.oninput = updateOverlay;
    imgUrl.onchange = () => { bg.src = imgUrl.value; };
    updateOverlay();

    // ---------- Crossfade state ----------
    let useA = true;   // which layer is currently visible
    let lastPick = "X";

    function pickSprite(v) {
      return HAVE[v] ? v : (FALLBACK[v] || "X");
    }

    function setViseme(v) {
      const pick = pickSprite(v);
      if (pick === lastPick) {
        visemeEl.textContent = v;
        return; // no asset change, keep showing
      }
      lastPick = pick;

      const nextImg = useA ? mouthB : mouthA; // the one that is currently hidden
      nextImg.src = `${MOUTH_BASE}${pick}.png`;

      // ensure the browser has a moment to load before fading in
      requestAnimationFrame(() => {
        // fade current out, next in
        if (useA) {
          mouthA.style.opacity = 0;
          mouthB.style.opacity = 1;
        } else {
          mouthA.style.opacity = 1;
          mouthB.style.opacity = 0;
        }
        useA = !useA;
      });

      visemeEl.textContent = v; // show requested letter
    }

    // ---------- Micro-motion (subtle bob + tilt) ----------
    // Tunables
    const MICRO = {
      bobPx: 1.2,          // base bob amplitude in pixels
      tiltDeg: 0.35,       // base tilt amplitude in degrees
      vowelBoost: 1.7,     // vowels A/E/I/O/U increase amplitude
      speed: 9.0           // oscillations per second (approx)
    };
    const VOWELS = new Set(["A","E","I","O","U"]);

    let playing = false, raf = null, t0 = 0;
    let baseScale = parseFloat(ms.value), baseRotate = parseFloat(mr.value);
    let currentV = "X";

    function animateTransform(now) {
      // time since start in seconds
      const t = (now - t0) / 1000;
      const isVowel = VOWELS.has(currentV);
      const boost = isVowel ? MICRO.vowelBoost : 1.0;
      const bob = Math.sin(t * 2 * Math.PI * MICRO.speed) * MICRO.bobPx * boost;
      const tilt = Math.sin(t * 2 * Math.PI * (MICRO.speed * 0.5)) * MICRO.tiltDeg * boost * 0.7;

      // apply only to mouth (keeps Emma image stable)
      mouth.style.transform = `translateY(${bob}px) scale(${baseScale}) rotate(${baseRotate + tilt}deg)`;
    }

    // ---------- Timeline & master animation ----------
    function fakeTimeline(text) {
      const clean = text.trim().replace(/\s+/g, " ");
      const groups = Math.max(10, Math.min(80, Math.ceil(clean.length / 3.6)));
      const seq = ["M","A","E","I","O","U","S","L","F","X"];
      return Array.from({ length: groups }, (_, i) => ({ t: i * 105, v: seq[i % seq.length] }));
    }

    function animate(marks) {
      t0 = performance.now();
      let i = 0;

      const step = (now) => {
        const elapsed = now - t0;

        // advance viseme index
        while (i < marks.length && elapsed >= marks[i].t) {
          currentV = marks[i].v;
          setViseme(currentV);
          i++;
        }

        // apply micro-motion every frame
        animateTransform(now);

        if (playing) raf = requestAnimationFrame(step);
      };

      if (raf) cancelAnimationFrame(raf);
      raf = requestAnimationFrame(step);
    }

    // ---------- Speak handler (browser TTS) ----------
    speakBtn.onclick = async () => {
      playing = true;
      const marks = fakeTimeline(txt.value);
      animate(marks);

      const synth = window.speechSynthesis;
      if (synth) {
        try { synth.cancel(); } catch(e) {}
        const u = new SpeechSynthesisUtterance(txt.value);
        u.rate = 1.0;
        synth.speak(u);
        await new Promise(res => { u.onend = res; u.onerror = res; });
      } else {
        const est = Math.max(1500, Math.min(8000, txt.value.length * 50));
        await new Promise(res => setTimeout(res, est));
      }

      playing = false;
      currentV = "X";
      setViseme("X");
      // reset transform back to base
      mouth.style.transform = `scale(${baseScale}) rotate(${baseRotate}deg)`;
    };
  </script>
</body>
</html>
